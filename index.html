<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented: Hounds and Jackals</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    /* Global Reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #fafafa;
      font-family: "Papyrus", cursive, serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1, h2, p {
      text-align: center;
      color: #8b4513;
    }
    /* Layout Wrapper */
    #gameWrapper {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      width: 100%;
      margin: 20px;
    }
    /* Left Panel (Dice Controls) */
    #leftPanel {
      min-width: 150px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Right Panel (Move History) */
    #rightPanel {
      min-width: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Game Container */
    #gameContainer {
      position: relative;
      width: 620px; /* canvas (600px) + padding */
      padding: 10px;
      background: #fff;
      border: 4px double #8b4513;
      border-radius: 6px;
    }
    canvas {
      display: block;
      background: #f5f2e8;
      margin: auto;
    }
    /* Overlay Screens */
    .overlayScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      border: 4px double #8b4513;
      border-radius: 6px;
      z-index: 10;
    }
    .overlayScreen.active {
      display: flex;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
      background: #ffcc00;
      border: none;
      border-radius: 6px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      color: #333;
      font-family: "Papyrus", cursive, serif;
    }
    /* Dice Display */
    #diceRollDisplay {
      font-size: 24px;
      padding: 10px;
      border: 2px solid #8b4513;
      border-radius: 6px;
      background: #fff;
      margin-bottom: 10px;
    }
    /* Move History */
    #moveHistory {
      font-size: 16px;
      padding: 10px;
      border: 2px solid #8b4513;
      border-radius: 6px;
      background: #fff;
      max-height: 400px;
      overflow-y: auto;
      width: 200px;
      text-align: left;
    }
    /* Logo */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <!-- Header Banner -->
  <div class="header-title">
    <h2>Another Product Invented</h2>
    <h1>Hounds and Jackals</h1>
  </div>

  <div id="gameWrapper">
    <!-- Left Panel: Dice Controls -->
    <div id="leftPanel">
      <div id="diceRollDisplay">Dice: -</div>
      <button id="rollDiceBtn">Roll Dice</button>
    </div>

    <!-- Center Panel: Game Container -->
    <div id="gameContainer">
      <!-- Overlays -->
      <div id="menuScreen" class="overlayScreen active">
        <h1>Hounds and Jackals</h1>
        <button id="newGameBtn">New Game</button>
        <button id="instructionsBtn">Instructions</button>
      </div>
      <div id="instructionsScreen" class="overlayScreen">
        <p>
          <strong>Classic Rules:</strong><br>
          • Each player has 5 pieces.<br>
          • To enter a piece onto the board, you must roll a 1 or a 6.<br>
          • Pieces move along a 30‑square path (exact roll required to finish).<br>
          • Landing on an opponent’s piece (if not on a safe square) sends it off‑board.<br>
          • You cannot land on a square occupied by your own piece (except in designated safe zones).<br>
          • Rolling a 6 grants an extra turn.<br>
          • The first to get all 5 pieces to the final square wins.<br>
          <br>
          Press [M] to return to the Main Menu.
        </p>
      </div>
      <div id="difficultyScreen" class="overlayScreen">
        <p>Select AI Difficulty:</p>
        <button id="easyBtn">Easy</button>
        <button id="mediumBtn">Medium</button>
        <button id="hardBtn">Hard</button>
      </div>
      <div id="gameOverScreen" class="overlayScreen">
        <h2 id="gameOverText"></h2>
        <button id="gameOverNewGameBtn">New Game</button>
        <p>Press [M] to return to the Main Menu.</p>
      </div>
      <canvas id="gameCanvas" width="600" height="180"></canvas>
    </div>

    <!-- Right Panel: Move History -->
    <div id="rightPanel">
      <div id="moveHistory">Moves:<br></div>
    </div>
  </div>

  <img id="logo" src="logo.png" alt="Logo">

  <script>
    'use strict';

    /***********************************
     * 1) Board & Canvas Setup
     ***********************************/
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const boardCols = 10, boardRows = 3;
    const squareSize = 60;
    const boardWidth = boardCols * squareSize;
    const boardHeight = boardRows * squareSize;
    const boardSquares = [];
    // Generate a 3x10 grid of squares
    for (let r = 0; r < boardRows; r++) {
      for (let c = 0; c < boardCols; c++) {
        boardSquares.push({
          x: c * squareSize,
          y: r * squareSize,
          w: squareSize,
          h: squareSize,
          safe: (r === 1 && (c === 2 || c === 7)) // Example safe zones on middle row
        });
      }
    }
    // Define the movement path in serpentine order (30 squares)
    let path = [];
    // First row: left-to-right
    for (let i = 0; i < boardCols; i++) path.push(i);
    // Second row: right-to-left
    for (let i = boardCols; i < 2 * boardCols; i++) path.push(2 * boardCols - 1 - (i - boardCols));
    // Third row: left-to-right
    for (let i = 2 * boardCols; i < 3 * boardCols; i++) path.push(i);

    /***********************************
     * 2) Game State Variables
     ***********************************/
    let gameState = "menu";  // "menu", "instructions", "selectDifficulty", "playing", "gameover"
    let humanSide = null;    // "hounds" or "jackals"
    let aiDifficulty = "medium";  // "easy", "medium", "hard"
    let currentTurn = null;       // "hounds" or "jackals"
    let currentDiceRoll = 0;
    let diceRolled = false;
    let extraTurn = false;
    let nextPlayer = null;
    const NUM_PIECES = 5;
    let houndsPieces = [], jackalsPieces = [];
    let moveHistory = [];
    let lastMove = null;

    /***********************************
     * 3) DOM Elements & Overlays
     ***********************************/
    const diceRollDisplay = document.getElementById("diceRollDisplay");
    const rollDiceBtn = document.getElementById("rollDiceBtn");
    const moveHistoryDiv = document.getElementById("moveHistory");
    const menuScreen = document.getElementById("menuScreen");
    const instructionsScreen = document.getElementById("instructionsScreen");
    const difficultyScreen = document.getElementById("difficultyScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const gameOverText = document.getElementById("gameOverText");

    /***********************************
     * 4) Initialization
     ***********************************/
    function initPieces() {
      houndsPieces = Array(NUM_PIECES).fill(-1);  // off-board
      jackalsPieces = Array(NUM_PIECES).fill(-1);
      lastMove = null;
      moveHistory = [];
      updateMoveHistoryDisplay();
    }

    /***********************************
     * 5) Dice Function
     ***********************************/
    function rollDice() {
      return Math.floor(Math.random() * 6) + 1;
    }

    /***********************************
     * 6) Drawing Functions
     ***********************************/
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      boardSquares.forEach((sq, idx) => {
        let grad = ctx.createLinearGradient(sq.x, sq.y, sq.x + sq.w, sq.y + sq.h);
        grad.addColorStop(0, "#f4e2c0");
        grad.addColorStop(1, "#c5a36c");
        ctx.fillStyle = grad;
        ctx.fillRect(sq.x, sq.y, sq.w, sq.h);
        ctx.strokeStyle = "#8b4513";
        ctx.lineWidth = 2;
        ctx.strokeRect(sq.x, sq.y, sq.w, sq.h);
        if (sq.safe) {
          ctx.save();
          ctx.translate(sq.x + sq.w/2, sq.y + sq.h/2);
          drawStar(0, 0, 5, 10, 5, "#ffcc00", "#8b4513", 2);
          ctx.restore();
        }
      });
    }
    function drawStar(cx, cy, spikes, outerRadius, innerRadius, fillColor, strokeColor, lineWidth) {
      let rot = Math.PI / 2 * 3;
      let x = cx;
      let y = cy;
      let step = Math.PI / spikes;
      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;
        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }
    function drawPieces() {
      // Draw hounds pieces (blue) and jackals pieces (red)
      houndsPieces.forEach((pos, i) => {
        if (pos === -1 || pos === 29) return;
        let sqIdx = path[pos];
        let sq = boardSquares[sqIdx];
        let cx = sq.x + sq.w/2;
        let cy = sq.y + sq.h/2;
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, 20, 0, Math.PI * 2);
        let grad = ctx.createRadialGradient(cx - 5, cy - 5, 5, cx, cy, 20);
        grad.addColorStop(0, "#99ccff");
        grad.addColorStop(1, "#003399");
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.font = "bold 16px sans-serif";
        ctx.fillStyle = "#000";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(i+1, cx, cy);
        ctx.restore();
      });
      jackalsPieces.forEach((pos, i) => {
        if (pos === -1 || pos === 29) return;
        let sqIdx = path[pos];
        let sq = boardSquares[sqIdx];
        let cx = sq.x + sq.w/2;
        let cy = sq.y + sq.h/2;
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, 20, 0, Math.PI * 2);
        let grad = ctx.createRadialGradient(cx - 5, cy - 5, 5, cx, cy, 20);
        grad.addColorStop(0, "#ff9999");
        grad.addColorStop(1, "#cc0000");
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.font = "bold 16px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(i+1, cx, cy);
        ctx.restore();
      });
    }
    function redrawPlayScreen() {
      drawBoard();
      drawPieces();
      updateDiceRollDisplay();
      updateMoveHistoryDisplay();
    }
    function updateDiceRollDisplay() {
      diceRollDisplay.textContent = `Dice: ${currentDiceRoll || "-"}`;
    }
    function addMoveToHistory(txt) {
      moveHistory.push(txt);
      if (moveHistory.length > 5) moveHistory.shift();
      updateMoveHistoryDisplay();
    }
    function updateMoveHistoryDisplay() {
      moveHistoryDiv.innerHTML = "Moves:<br>" + moveHistory.join("<br>");
    }

    /***********************************
     * 7) Movement & Rule Functions
     ***********************************/
    // Pieces start off-board at -1. To enter, must roll 1 or 6.
    function getValidMove(piecePos, diceValue, color) {
      if (piecePos === -1) {
        if (diceValue === 1 || diceValue === 6) return 0;
        return null;
      }
      let target = piecePos + diceValue;
      if (target > 29) return null; // Must land exactly on 29
      return target;
    }
    function canLandOn(pos, color) {
      let own = (color === "hounds") ? houndsPieces : jackalsPieces;
      if (own.includes(pos)) return false;
      return true;
    }
    function getMoveOptions(diceValue, color) {
      let opts = [];
      let own = (color === "hounds") ? houndsPieces : jackalsPieces;
      for (let i = 0; i < own.length; i++) {
        let pos = own[i];
        let newPos = getValidMove(pos, diceValue, color);
        if (newPos === null) continue;
        if (!canLandOn(newPos, color)) continue;
        opts.push({ pieceIndex: i, fromPos: pos, toPos: newPos });
      }
      return opts;
    }
    function executeMove(pieceIndex, toPos, color) {
      let own = (color === "hounds") ? houndsPieces : jackalsPieces;
      let opp = (color === "hounds") ? jackalsPieces : houndsPieces;
      let fromPos = own[pieceIndex];
      // Capture rule: if landing on opponent and square is not safe, capture it.
      if (toPos !== 0 && toPos !== 29) {
        if (opp.includes(toPos)) {
          let sq = boardSquares[path[toPos]];
          if (!sq.safe) {
            let oppIdx = opp.indexOf(toPos);
            opp[oppIdx] = -1;
            addMoveToHistory(`${color} captured an opponent's piece at square ${toPos+1}`);
          }
        }
      }
      own[pieceIndex] = toPos;
      addMoveToHistory(`${color} moved piece #${pieceIndex+1} from ${fromPos === -1 ? "off-board" : fromPos+1} to ${toPos+1}`);
      lastMove = { fromPos, toPos, color, pieceIndex };
      if (currentDiceRoll === 6) {
        extraTurn = true;
        nextPlayer = color;
      } else {
        extraTurn = false;
        nextPlayer = (color === "hounds") ? "jackals" : "hounds";
      }
      let finished = own.filter(p => p === 29).length;
      if (finished === NUM_PIECES) {
        gameOverText.textContent = (color === humanSide) ? "You Win!" : "You Lose!";
        addMoveToHistory(`${color} wins the game!`);
        showGameOver();
      }
    }

    /***********************************
     * 8) Turn Management
     ***********************************/
    function endTurn(isHumanTurn) {
      diceRolled = false;
      currentDiceRoll = 0;
      setTimeout(() => {
        currentTurn = nextPlayer;
        addMoveToHistory(`${currentTurn} Turn! Roll dice...`);
        redrawPlayScreen();
        if (currentTurn !== humanSide) {
          setTimeout(aiAutoRoll, 2000);
        }
      }, isHumanTurn ? 1000 : 2000);
    }

    /***********************************
     * 9) Human Interaction
     ***********************************/
    function humanRollDice() {
      if (gameState !== "playing") return;
      if (currentTurn !== humanSide) return;
      if (diceRolled) return;
      currentDiceRoll = rollDice();
      diceRolled = true;
      addMoveToHistory(`${humanSide} rolled ${currentDiceRoll}`);
      showTemporaryMessage(`${humanSide} rolled ${currentDiceRoll}`);
      redrawPlayScreen();
      let opts = getMoveOptions(currentDiceRoll, currentTurn);
      if (opts.length === 0) {
        showTemporaryMessage("No legal moves. Passing turn...");
        nextPlayer = (currentTurn === "hounds") ? "jackals" : "hounds";
        diceRolled = false;
        currentDiceRoll = 0;
        endTurn(true);
      }
    }
    function handleBoardClick(e) {
      if (gameState !== "playing") return;
      if (currentTurn !== humanSide) return;
      if (!diceRolled) return;
      let opts = getMoveOptions(currentDiceRoll, currentTurn);
      if (opts.length === 0) return;
      let rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left, my = e.clientY - rect.top;
      let own = (currentTurn === "hounds") ? houndsPieces : jackalsPieces;
      for (let i = 0; i < own.length; i++) {
        let pos = own[i];
        if (pos === 29) continue;
        let sqIdx = path[pos === -1 ? 0 : pos];
        let sq = boardSquares[sqIdx];
        let cx = sq.x + sq.w/2, cy = sq.y + sq.h/2;
        let dx = mx - cx, dy = my - cy;
        if (Math.sqrt(dx*dx + dy*dy) <= 20) {
          let found = opts.find(o => o.pieceIndex === i);
          if (!found) {
            showTemporaryMessage("Illegal move!");
            return;
          }
          if (!executeMove(i, found.toPos, currentTurn)) return;
          redrawPlayScreen();
          showTemporaryMessage(`${currentTurn} moved piece #${i+1}`);
          endTurn(true);
          return;
        }
      }
    }

    /***********************************
     * 10) AI Turn
     ***********************************/
    function aiAutoRoll() {
      if (gameState !== "playing") return;
      if (currentTurn === humanSide) return;
      if (!diceRolled) {
        currentDiceRoll = rollDice();
        diceRolled = true;
        addMoveToHistory(`${currentTurn} rolled ${currentDiceRoll}`);
        showTemporaryMessage(`${currentTurn} rolled ${currentDiceRoll}`);
        redrawPlayScreen();
        setTimeout(aiMakeMove, 2000);
      }
    }
    function aiMakeMove() {
      let opts = getMoveOptions(currentDiceRoll, currentTurn);
      if (opts.length === 0) {
        showTemporaryMessage("AI has no moves. Passing turn...");
        nextPlayer = (currentTurn === "hounds") ? "jackals" : "hounds";
        diceRolled = false;
        currentDiceRoll = 0;
        endTurn(false);
        return;
      }
      let pick;
      if (aiDifficulty === "easy") {
        pick = opts[Math.floor(Math.random() * opts.length)];
      } else if (aiDifficulty === "medium") {
        let captureMoves = opts.filter(o => {
          let opp = (currentTurn === "hounds") ? jackalsPieces : houndsPieces;
          return opp.includes(o.toPos);
        });
        pick = (captureMoves.length > 0) ? captureMoves[Math.floor(Math.random() * captureMoves.length)] : opts[Math.floor(Math.random() * opts.length)];
      } else if (aiDifficulty === "hard") {
        let captureMoves = opts.filter(o => {
          let opp = (currentTurn === "hounds") ? jackalsPieces : houndsPieces;
          return opp.includes(o.toPos);
        });
        if (captureMoves.length > 0) {
          pick = captureMoves[Math.floor(Math.random() * captureMoves.length)];
        } else {
          pick = opts.reduce((best, o) => (o.fromPos < best.fromPos ? o : best), opts[0]);
        }
      }
      if (!executeMove(pick.pieceIndex, pick.toPos, currentTurn)) {
        nextPlayer = (currentTurn === "hounds") ? "jackals" : "hounds";
        diceRolled = false;
        currentDiceRoll = 0;
        endTurn(false);
        return;
      }
      redrawPlayScreen();
      if (extraTurn) {
        showTemporaryMessage(`${currentTurn} goes again!`);
        diceRolled = false;
        currentDiceRoll = 0;
        aiAutoRoll();
      } else {
        endTurn(false);
      }
    }

    /***********************************
     * 11) Temporary Messages
     ***********************************/
    function showTemporaryMessage(msg) {
      const overlay = document.getElementById("diceMessageOverlay");
      overlay.textContent = msg;
      overlay.style.display = "block";
      setTimeout(() => { overlay.style.display = "none"; }, 2000);
    }

    /***********************************
     * 12) Overlays & Navigation
     ***********************************/
    function hideAllScreens() {
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu() {
      hideAllScreens();
      gameState = "menu";
      menuScreen.style.display = "flex";
    }
    function showInstructions() {
      hideAllScreens();
      gameState = "instructions";
      instructionsScreen.style.display = "flex";
    }
    function showDifficultyScreen() {
      hideAllScreens();
      gameState = "selectDifficulty";
      difficultyScreen.style.display = "flex";
    }
    function setDifficulty(d) {
      aiDifficulty = d;
      startPlaying();
    }
    function startPlaying() {
      hideAllScreens();
      gameState = "playing";
      initPieces();
      currentTurn = "hounds"; // Hounds always start (if human is hounds, human goes first)
      diceRolled = false;
      currentDiceRoll = 0;
      extraTurn = false;
      addMoveToHistory("Hounds Turn! Roll dice...");
      showTemporaryMessage("Hounds Turn! Roll dice...");
      redrawPlayScreen();
      if (currentTurn !== humanSide) {
        setTimeout(aiAutoRoll, 2000);
      }
    }
    function showGameOver() {
      hideAllScreens();
      gameState = "gameover";
      gameOverScreen.style.display = "flex";
    }

    /***********************************
     * 13) Buttons & Keyboard
     ***********************************/
    document.getElementById("newGameBtn").onclick = () => showDifficultyScreen();
    document.getElementById("instructionsBtn").onclick = () => showInstructions();
    document.getElementById("gameOverNewGameBtn") && (document.getElementById("gameOverNewGameBtn").onclick = () => showDifficultyScreen());
    rollDiceBtn.addEventListener("click", humanRollDice);
    canvas.addEventListener("mousedown", handleBoardClick);
    document.addEventListener("keydown", (e) => {
      let key = e.key.toLowerCase();
      if (gameState === "selectDifficulty") {
        if (key === "e") setDifficulty("easy");
        else if (key === "m") setDifficulty("medium");
        else if (key === "h") setDifficulty("hard");
      } else if (gameState === "playing") {
        if (key === "r" && currentTurn === humanSide && !diceRolled) {
          humanRollDice();
        } else if (key === "m") {
          initPieces();
          showMenu();
        }
      } else if (gameState === "instructions" || gameState === "gameover") {
        if (key === "m") {
          initPieces();
          showMenu();
        }
      }
    });

    /***********************************
     * 14) Main Loop
     ***********************************/
    function mainLoop() {
      if (gameState === "playing") {
        redrawPlayScreen();
        rollDiceBtn.style.display = (currentTurn === humanSide) ? "inline-block" : "none";
      }
      requestAnimationFrame(mainLoop);
    }
    function startAll() {
      showMenu();
      requestAnimationFrame(mainLoop);
    }
    window.addEventListener("load", startAll);
  </script>
</body>
</html>
