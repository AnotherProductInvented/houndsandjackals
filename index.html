<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hounds and Jackals</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    /* Global Reset & Basic Styles */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #fafafa;
      font-family: "Papyrus", cursive, serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1, h2, p { text-align: center; color: #8b4513; }
    /* Layout */
    #gameWrapper {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      width: 100%;
      margin: 20px;
    }
    /* Left Panel */
    #leftPanel {
      min-width: 150px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #releaseControls { margin-top: 15px; }
    #releaseControls button { margin: 5px; padding: 5px 10px; font-size: 16px; }
    #offBoardCounts { margin-top: 10px; font-size: 16px; }
    #unusedRollBtn {
      display: none;
      margin: 5px;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      background: #ffcc00;
      border: none;
      border-radius: 6px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      color: #333;
      font-family: "Papyrus", cursive, serif;
    }
    /* Right Panel */
    #rightPanel {
      min-width: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #moveHistory {
      font-size: 16px;
      padding: 10px;
      border: 2px solid #8b4513;
      border-radius: 6px;
      background: #fff;
      max-height: 400px;
      overflow-y: auto;
      width: 200px;
      text-align: left;
      user-select: text !important;
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      -ms-user-select: text !important;
      white-space: pre-wrap;
      word-wrap: break-word;
      cursor: text;
      pointer-events: auto;
      position: relative;
      z-index: 100;
      -webkit-user-drag: auto;
      -webkit-touch-callout: default;
    }
    #copyHistoryBtn {
      margin-top: 10px;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      background: #ffcc00;
      border: none;
      border-radius: 6px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      color: #333;
      font-family: "Papyrus", cursive, serif;
      z-index: 100;
    }
    /* Center Panel */
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 900px;
      padding: 20px 20px 80px 20px;
      background: linear-gradient(to bottom, #f5e6ca, #ecd8b5);
      border: 10px double #8b4513;
      border-radius: 6px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: radial-gradient(#fef9e7, #e8d6a4);
      margin: auto;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }
    /* Overlays */
    .overlayScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      border: 10px double #8b4513;
      border-radius: 6px;
      z-index: 10;
      overflow-y: auto;
    }
    .overlayScreen.active { display: flex; }
    /* Instructions */
    #instructionsContent { font-size: 20px; margin: 10px; }
    #instructionsNav { margin-top: 10px; }
    /* Global Button Styles */
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
      background: #ffcc00;
      border: none;
      border-radius: 6px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      color: #333;
      font-family: "Papyrus", cursive, serif;
    }
    /* Dice Display */
    #diceRollDisplay {
      font-size: 24px;
      padding: 10px;
      border: 2px solid #8b4513;
      border-radius: 6px;
      background: #fff;
      margin-bottom: 10px;
    }
    /* Temporary Message Overlay */
    #diceMessageOverlay {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 20px;
      background: rgba(255,255,255,0.9);
      border: 2px solid #8b4513;
      border-radius: 6px;
      font-family: "Papyrus", cursive, serif;
      font-size: 28px;
      color: #8b4513;
      display: none;
      z-index: 1500;
    }
    /* Logo */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <div class="header-title">
    <h2>Another Product Invented</h2>
    <h1>Hounds and Jackals</h1>
  </div>
  <div id="gameWrapper">
    <div id="leftPanel">
      <div id="diceRollDisplay">Dice: -</div>
      <button id="rollDiceBtn">Roll Dice</button>
      <button id="unusedRollBtn">Use Unused Roll</button>
      <input type="number" id="customDiceInput" min="1" max="6" placeholder="Set Dice (1-6)">
      <button id="setCustomDiceBtn">Use Custom Dice</button>
      <div id="releaseControls">
        <button id="releaseHoundBtn">Release Hound</button>
      </div>
      <div id="offBoardCounts">
        <span id="houndsCount">Hounds Off-board: 5</span><br>
        <span id="jackalsCount">Jackals Off-board: 5</span>
      </div>
    </div>
    <div id="gameContainer">
      <div id="diceMessageOverlay"></div>
      <div id="menuScreen" class="overlayScreen active">
        <h1>Hounds and Jackals</h1>
        <button id="newGameBtn">New Game</button>
        <button id="instructionsBtn">Instructions</button>
      </div>
      <div id="instructionsScreen" class="overlayScreen">
        <div id="instructionsContent"></div>
        <div id="instructionsNav">
          <button id="instructionsPrevBtn">Previous</button>
          <button id="instructionsNextBtn">Next</button>
        </div>
      </div>
      <div id="difficultyScreen" class="overlayScreen">
        <p>Select AI Difficulty:</p>
        <button id="easyBtn">Easy</button>
        <button id="mediumBtn">Medium</button>
        <button id="hardBtn">Hard</button>
      </div>
      <div id="gameOverScreen" class="overlayScreen">
        <h2 id="gameOverText"></h2>
        <button id="gameOverNewGameBtn">New Game</button>
        <p>Press [M] to return to the Main Menu.</p>
      </div>
      <div id="jackalsTray" style="display: flex; gap: 10px; justify-content: center; margin-bottom: 10px;"></div>
      <canvas id="gameCanvas" width="820" height="320" style="width: 100%; height: auto;"></canvas>
      <div id="houndsTray" style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;"></div>
    </div>
    <div id="rightPanel">
      <div id="moveHistory" contenteditable="true">Moves:<br></div>
      <button id="copyHistoryBtn">Copy History</button>
    </div>
  </div>
  <img id="logo" src="logo.png" alt="Logo">
  <script>
    /* Utility: Remove white background from an image */
    function removeWhiteBackground(image, callback) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = image.width;
      tempCanvas.height = image.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(image, 0, 0);
      const imgData = tempCtx.getImageData(0, 0, image.width, image.height);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        if (data[i] >= 240 && data[i+1] >= 240 && data[i+2] >= 240) {
          data[i+3] = 0;
        }
      }
      tempCtx.putImageData(imgData, 0, 0);
      const newImage = new Image();
      newImage.src = tempCanvas.toDataURL();
      newImage.onload = () => callback(newImage);
    }

    let aiTimeout = null;

    window.addEventListener("load", function() {
      const debugMode = true;
      function debugLog(msg) { if (debugMode) console.log("[DEBUG]", msg); }
      debugLog("Page loaded. Initializing game...");

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const diceRollDisplayEl = document.getElementById("diceRollDisplay");
      const rollDiceBtn = document.getElementById("rollDiceBtn");
      const unusedRollBtn = document.getElementById("unusedRollBtn");
      const moveHistoryDiv = document.getElementById("moveHistory");
      const menuScreenEl = document.getElementById("menuScreen");
      const instructionsScreenEl = document.getElementById("instructionsScreen");
      const difficultyScreenEl = document.getElementById("difficultyScreen");
      const gameOverScreenEl = document.getElementById("gameOverScreen");
      const gameOverTextEl = document.getElementById("gameOverText");
      const instructionsContentEl = document.getElementById("instructionsContent");
      const instructionsPrevBtn = document.getElementById("instructionsPrevBtn");
      const instructionsNextBtn = document.getElementById("instructionsNextBtn");
      const customDiceInput = document.getElementById("customDiceInput");
      const setCustomDiceBtn = document.getElementById("setCustomDiceBtn");
      const copyHistoryBtn = document.getElementById("copyHistoryBtn");

      copyHistoryBtn.addEventListener("click", () => {
        const historyText = moveHistoryDiv.innerText;
        navigator.clipboard.writeText(historyText)
          .then(() => { showTemporaryMessage("History copied to clipboard!"); debugLog("History copied."); })
          .catch(err => { showTemporaryMessage("Failed to copy history!"); debugLog("Copy error: " + err); });
      });

      const boardPath = [];
      const boardSquares = {};
      const boardPathHounds = ["E5","E6","E7","E8","E9",
        "D15","D14","D13","D12","D11","D10","D9","D8","D7","D6","D5","D4","D3","D2","D1",
        "C1","C2","C3","C4","C5","C6","C7","C8","C9","C10"];
      const boardPathJackals = ["E5","E4","E3","E2","E1",
        "A15","A14","A13","A12","A11","A10","A9","A8","A7","A6","A5","A4","A3","A2","A1",
        "B1","B2","B3","B4","B5","B6","B7","B8","B9","B10"];
      const SLOT_RADIUS = 7, SLOT_SPACING = 44, START_X = 40, START_Y = 100;
      debugLog("Setting up board squares and path.");
      for (let i = 1; i <= 15; i++) {
        boardSquares[`A${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y };
        boardPath.push(`A${i}`);
      }
      for (let i = 1; i <= 15; i++) {
        boardSquares[`D${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 3.6 };
        boardPath.push(`D${i}`);
      }
      for (let i = 1; i <= 10; i++) {
        boardSquares[`B${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 1.2 };
        boardPath.push(`B${i}`);
      }
      for (let i = 1; i <= 10; i++) {
        boardSquares[`C${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 2.4 };
        boardPath.push(`C${i}`);
      }
      const archCenters = [
        { x: boardSquares["A15"].x + SLOT_SPACING * 0.65, y: boardSquares["A15"].y + SLOT_SPACING * 0.2 },
        { x: boardSquares["A15"].x + SLOT_SPACING * 1.3,  y: boardSquares["A15"].y + SLOT_SPACING * 0.4 },
        { x: boardSquares["A15"].x + SLOT_SPACING * 2.0,  y: boardSquares["A15"].y + SLOT_SPACING * 0.7 },
        { x: boardSquares["A15"].x + SLOT_SPACING * 2.6,  y: boardSquares["A15"].y + SLOT_SPACING * 1.2 },
        { x: boardSquares["A15"].x + SLOT_SPACING * 3.2,  y: boardSquares["A15"].y + SLOT_SPACING * 1.9 },
        { x: boardSquares["A15"].x + SLOT_SPACING * 2.6,  y: boardSquares["A15"].y + SLOT_SPACING * 2.6 },
        { x: boardSquares["A15"].x + SLOT_SPACING * 2.0,  y: boardSquares["A15"].y + SLOT_SPACING * 3.1 },
        { x: boardSquares["A15"].x + SLOT_SPACING * 1.3,  y: boardSquares["A15"].y + SLOT_SPACING * 3.4 },
        { x: (boardSquares["D15"].x + boardSquares["A15"].x + SLOT_SPACING * 1.3) / 2,
          y: (boardSquares["D15"].y + boardSquares["A15"].y + SLOT_SPACING * 3.4) / 2 }
      ];
      for (let i = 0; i < 9; i++) {
        boardSquares[`E${i + 1}`] = archCenters[i];
        boardPath.push(`E${i + 1}`);
      }
      debugLog("Board setup complete.");

      let gameState = "menu",
          humanSide = "hounds",
          aiDifficulty = "medium",
          currentTurn = "hounds",
          currentDiceRoll = 0,
          diceRolled = false,
          extraTurn = false,
          nextPlayer = "jackals",
          NUM_PIECES = 5,
          houndsPieces = [],
          jackalsPieces = [],
          moveHistory = [],
          lastMove = null,
          unusedRoll = null,
          unusedRollOwner = null;
      debugLog("Game state variables initialized.");

      let houndsImg = new Image(), jackalsImg = new Image();
      houndsImg.src = "hounds.png";
      houndsImg.crossOrigin = "anonymous";
      jackalsImg.src = "jackals.png";
      jackalsImg.crossOrigin = "anonymous";
      houndsImg.onload = () => {
        debugLog("houndsImg loaded; cleaning...");
        removeWhiteBackground(houndsImg, (cleaned) => { houndsImg = cleaned; debugLog("houndsImg cleaned."); });
      };
      jackalsImg.onload = () => {
        debugLog("jackalsImg loaded; cleaning...");
        removeWhiteBackground(jackalsImg, (cleaned) => { jackalsImg = cleaned; debugLog("jackalsImg cleaned."); });
      };

      function initPieces() {
        debugLog("initPieces: called");
        houndsPieces = Array(NUM_PIECES).fill(-1);
        jackalsPieces = Array(NUM_PIECES).fill(-1);
        lastMove = null;
        moveHistory = [];
        updateMoveHistoryDisplay();
        updateTrays();
        prepareTrayImages(() => { redrawPlayScreen(); debugLog("initPieces: tray images prepared."); });
        debugLog("initPieces: Pieces initialized.");
        updateOffBoardCounts();
      }

      function rollDice() {
        const roll = Math.floor(Math.random() * 6) + 1;
        debugLog("rollDice: rolled " + roll);
        return roll;
      }
      function processDiceRoll(diceValue) {
        debugLog("processDiceRoll: starting with value " + diceValue);
        // Preserve the roll value in a temporary variable.
        const rollValue = diceValue;
        currentDiceRoll = rollValue;
        diceRolled = true;
        addMoveToHistory(`${currentTurn} rolled ${rollValue}`);
        showTemporaryMessage(`${currentTurn} rolled ${rollValue}`);
        redrawPlayScreen();
        let opts = getMoveOptions(rollValue, currentTurn);
        debugLog("processDiceRoll: legal moves count = " + opts.length);
        if (opts.length === 0) {
          if (currentTurn === humanSide) {
            nextPlayer = "jackals";
            unusedRoll = rollValue;
            unusedRollOwner = nextPlayer;
            addMoveToHistory(`${currentTurn} has no legal moves; roll (${rollValue}) passed to ${nextPlayer}.`);
          } else {
            nextPlayer = "hounds";
            unusedRoll = rollValue;
            unusedRollOwner = nextPlayer;
            addMoveToHistory(`${currentTurn} has no legal moves; roll (${rollValue}) passed to ${nextPlayer}.`);
          }
          diceRolled = false;
          currentDiceRoll = 0;
          currentTurn = nextPlayer;
          updateTurn();
          return;
        }
      }

      function drawBoard() {
        debugLog("drawBoard: starting");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        Object.entries(boardSquares).forEach(([label, sq]) => {
          ctx.beginPath();
          ctx.arc(sq.x, sq.y, SLOT_RADIUS, 0, Math.PI * 2);
          let grad;
          if (["B6","B7","B8","B9","B10"].includes(label)) {
            grad = ctx.createRadialGradient(sq.x, sq.y, 5, sq.x, sq.y, SLOT_RADIUS);
            grad.addColorStop(0, "#aad4ff");
            grad.addColorStop(1, "#005fa3");
          } else if (["C6","C7","C8","C9","C10"].includes(label)) {
            grad = ctx.createRadialGradient(sq.x, sq.y, 5, sq.x, sq.y, SLOT_RADIUS);
            grad.addColorStop(0, "#aaf0aa");
            grad.addColorStop(1, "#007a3d");
          } else {
            grad = ctx.createRadialGradient(sq.x, sq.y, 5, sq.x, sq.y, SLOT_RADIUS);
            grad.addColorStop(0, "#fcebbd");
            grad.addColorStop(1, "#b38b4d");
          }
          ctx.fillStyle = grad;
          ctx.fill();
          ctx.strokeStyle = "#6b4e2e";
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.fillText(label, sq.x, sq.y - 18);
        });
        ["A5", "A15", "D5", "D15", "E5"].forEach(label => {
          const sq = boardSquares[label];
          ctx.beginPath();
          ctx.arc(sq.x, sq.y, SLOT_RADIUS + 3, 0, Math.PI * 2);
          ctx.lineWidth = 3;
          ctx.strokeStyle = "#8b0000";
          ctx.stroke();
        });
        drawDoubleArrow(boardSquares["A10"], boardSquares["B5"], "between");
        drawDoubleArrow(boardSquares["D10"], boardSquares["C5"], "between");
        drawDoubleArrow(boardSquares["B1"], boardSquares["B3"]);
        drawDoubleArrow(boardSquares["C1"], boardSquares["C3"], "below");
        debugLog("drawBoard: complete");
      }
      function drawDoubleArrow(from, to, direction = "above") {
        debugLog(`drawDoubleArrow: from (${from.x},${from.y}) to (${to.x},${to.y}), direction=${direction}`);
        let midX = (from.x + to.x) / 2, midY;
        if (direction === "above") {
          midY = (from.y + to.y) / 2 - SLOT_SPACING * 0.75;
        } else if (direction === "below") {
          midY = (from.y + to.y) / 2 + SLOT_SPACING * 0.75;
        } else if (direction === "between") {
          midY = (from.y + to.y) / 2;
          midX += (from.x < to.x ? SLOT_SPACING * 0.9 : -SLOT_SPACING * 0.9);
        }
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.quadraticCurveTo(midX, midY, to.x, to.y);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.stroke();
        function drawArrowhead(x, y, angle) {
          const len = 10;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x - len * Math.cos(angle - Math.PI/6),
                     y - len * Math.sin(angle - Math.PI/6));
          ctx.lineTo(x - len * Math.cos(angle + Math.PI/6),
                     y - len * Math.sin(angle + Math.PI/6));
          ctx.closePath();
          ctx.fillStyle = "#000";
          ctx.fill();
        }
        function getCurveAngle(x0, y0, cx, cy, x1, y1, t = 0.99) {
          const dx = 2 * (1 - t) * (cx - x0) + 2 * t * (x1 - cx);
          const dy = 2 * (1 - t) * (cy - y0) + 2 * t * (y1 - cy);
          return Math.atan2(dy, dx);
        }
        const angleStart = getCurveAngle(to.x, to.y, midX, midY, from.x, from.y);
        drawArrowhead(from.x, from.y, angleStart);
        const angleEnd = getCurveAngle(from.x, from.y, midX, midY, to.x, to.y);
        drawArrowhead(to.x, to.y, angleEnd);
        debugLog("drawDoubleArrow: complete");
      }
      function drawPieces() {
        debugLog("drawPieces: starting");
        houndsPieces.forEach((pos, i) => {
          if (pos === -1 || pos === 29) return;
          const label = boardPathHounds[pos];
          const sq = boardSquares[label];
          ctx.drawImage(houndsImg, sq.x - 20, sq.y - 20, 40, 40);
        });
        jackalsPieces.forEach((pos, i) => {
          if (pos === -1 || pos === 29) return;
          const label = boardPathJackals[pos];
          const sq = boardSquares[label];
          ctx.drawImage(jackalsImg, sq.x - 20, sq.y - 20, 40, 40);
        });
        debugLog("drawPieces: complete");
      }
      function redrawPlayScreen() {
        debugLog("redrawPlayScreen: starting");
        drawBoard();
        drawPieces();
        updateDiceRollDisplay();
        updateMoveHistoryDisplay();
        updateTrays();
        updateUnusedRollButton();
        debugLog("redrawPlayScreen: complete");
      }
      function updateDiceRollDisplay() {
        diceRollDisplayEl.textContent = `Dice: ${currentDiceRoll || "-"}`;
        debugLog("updateDiceRollDisplay: currentDiceRoll = " + currentDiceRoll);
      }
      function addMoveToHistory(txt) {
        moveHistory.push(txt);
        updateMoveHistoryDisplay();
        debugLog("addMoveToHistory: " + txt);
      }
      function updateMoveHistoryDisplay() {
        moveHistoryDiv.innerHTML = "Moves:<br>" + moveHistory.join("<br>");
      }

      /* -------------------------
         Unused Roll Handling
         ------------------------- */
      function updateUnusedRollButton() {
        if (gameState === "playing" && currentTurn === humanSide && unusedRoll !== null && unusedRollOwner === humanSide) {
          unusedRollBtn.style.display = "inline-block";
          unusedRollBtn.textContent = "Use Unused Roll (" + unusedRoll + ")";
        } else {
          unusedRollBtn.style.display = "none";
        }
      }
      unusedRollBtn.addEventListener("click", function() {
        debugLog("unusedRollBtn clicked. Using unused roll: " + unusedRoll);
        processDiceRoll(unusedRoll);
        unusedRoll = null;
        unusedRollOwner = null;
      });

      function attemptUnusedRoll() {
        if (unusedRoll !== null && unusedRollOwner === currentTurn && currentTurn !== humanSide) {
          debugLog("AI auto-using unused roll: " + unusedRoll);
          processDiceRoll(unusedRoll);
          unusedRoll = null;
          unusedRollOwner = null;
          return true;
        }
        return false;
      }

      /* -------------------------
         Turn Updating
         ------------------------- */
      function updateTurn() {
        currentDiceRoll = 0;
        diceRolled = false;
        updateUnusedRollButton();
        addMoveToHistory(`${currentTurn}'s Turn! Roll dice...`);
        showTemporaryMessage(`${currentTurn}'s Turn! Roll dice...`);
        redrawPlayScreen();
        if (aiTimeout) clearTimeout(aiTimeout);
        if (currentTurn !== humanSide && !attemptUnusedRoll()) {
          aiTimeout = setTimeout(aiAutoRoll, 2000);
        }
      }
      function completeMove(usingUnused) {
        if (usingUnused) {
          unusedRoll = null;
          unusedRollOwner = null;
          updateUnusedRollButton();
          updateTurn();
        } else {
          if (extraTurn) {
            extraTurn = false;
            addMoveToHistory(`${currentTurn} gets another turn!`);
            showTemporaryMessage(`${currentTurn} gets another turn!`);
            updateTurn();
          } else {
            currentTurn = (currentTurn === "hounds") ? "jackals" : "hounds";
            updateTurn();
          }
        }
      }

      /* -------------------------
         Tray and Off-Board Updates
         ------------------------- */
      let imagesReady = false;
      function prepareTrayImages(callback) {
        debugLog("prepareTrayImages: starting");
        let readyCount = 0;
        function checkReady() {
          readyCount++;
          if (readyCount === 2) { imagesReady = true; debugLog("prepareTrayImages: images ready"); callback(); }
        }
        removeWhiteBackground(houndsImg, (cleaned) => { houndsImg = cleaned; checkReady(); });
        removeWhiteBackground(jackalsImg, (cleaned) => { jackalsImg = cleaned; checkReady(); });
      }
      function updateTrays() {
        debugLog("updateTrays: starting");
        if (!imagesReady) return;
        const houndsTray = document.getElementById("houndsTray");
        const jackalsTray = document.getElementById("jackalsTray");
        houndsTray.innerHTML = "";
        jackalsTray.innerHTML = "";
        updateOffBoardCounts();
        debugLog("updateTrays: complete");
      }
      function updateOffBoardCounts() {
        const hCount = houndsPieces.filter(p => p === -1).length;
        const jCount = jackalsPieces.filter(p => p === -1).length;
        document.getElementById("houndsCount").textContent = "Hounds Off-board: " + hCount;
        document.getElementById("jackalsCount").textContent = "Jackals Off-board: " + jCount;
        debugLog("updateOffBoardCounts: hounds=" + hCount + ", jackals=" + jCount);
      }

      /* -------------------------
         Movement & Rules Functions
         ------------------------- */
      function getValidMove(piecePos, diceValue, color) {
        debugLog(`getValidMove: ${color} piece at ${piecePos} with dice ${diceValue}`);
        if (piecePos === -1) return (diceValue === 6 ? 0 : null);
        let target = piecePos + diceValue;
        if (target > 29) return null;
        return target;
      }
      function canLandOn(pos, color) {
        let own = (color === "hounds") ? houndsPieces : jackalsPieces;
        return !own.includes(pos);
      }
      function getMoveOptions(diceValue, color) {
        debugLog(`getMoveOptions: calculating options for ${color} with dice ${diceValue}`);
        let opts = [];
        let own = (color === "hounds") ? houndsPieces : jackalsPieces;
        for (let i = 0; i < own.length; i++) {
          let pos = own[i];
          let label = (color === "hounds") ? boardPathHounds[pos] : boardPathJackals[pos];
          if ((color === "hounds" && ["B6","B7","B8","B9","B10"].includes(label)) ||
              (color === "jackals" && ["C6","C7","C8","C9"].includes(label)))
            continue;
          let newPos = getValidMove(pos, diceValue, color);
          if (newPos === null || !canLandOn(newPos, color)) continue;
          opts.push({ pieceIndex: i, fromPos: pos, toPos: newPos });
        }
        debugLog("getMoveOptions: options for " + color + " = " + JSON.stringify(opts));
        return opts;
      }
      function executeMove(pieceIndex, toPos, color) {
        debugLog(`executeMove: moving ${color} piece #${pieceIndex} to ${toPos}`);
        try {
          let own = (color === "hounds") ? houndsPieces : jackalsPieces;
          let fromPos = own[pieceIndex];
          const teleportPairs = {
            "A10": "B5", "B5": "A10",
            "D10": "C5", "C5": "D10",
            "B1": "B3", "B3": "B1",
            "C1": "C3", "C3": "C1"
          };
          own[pieceIndex] = toPos;
          let currentLabel = (color === "hounds") ? boardPathHounds[toPos] : boardPathJackals[toPos];
          if (teleportPairs[currentLabel]) {
            let targetLabel = teleportPairs[currentLabel];
            let targetIndex = (color === "hounds") ? boardPathHounds.indexOf(targetLabel) : boardPathJackals.indexOf(targetLabel);
            if (targetIndex !== -1 && canLandOn(targetIndex, color)) {
              debugLog(`executeMove: teleporting ${color} piece from ${currentLabel} to ${targetLabel}`);
              own[pieceIndex] = targetIndex;
              addMoveToHistory(`${color} teleported from ${currentLabel} to ${targetLabel}`);
              showTemporaryMessage(`${color} teleported to ${targetLabel}`);
              toPos = targetIndex;
            }
          }
          addMoveToHistory(`${color} moved piece #${pieceIndex+1} from ${fromPos === -1 ? "off-board" : fromPos+1} to ${toPos+1}`);
          lastMove = { fromPos, toPos, color, pieceIndex };
          const landedLabel = (color === "hounds") ? boardPathHounds[toPos] : boardPathJackals[toPos];
          if (["A5", "A15", "D5", "D15", "E5"].includes(landedLabel)) {
            extraTurn = true;
            addMoveToHistory(`${color} landed on ${landedLabel}, gets another turn!`);
            showTemporaryMessage(`${color} gets another turn!`);
          }
          let finished = own.filter(p => p === 29).length;
          if (finished === NUM_PIECES) {
            if (checkSpecialVictoryCondition()) return true;
            gameOverTextEl.textContent = (color === humanSide) ? "You Win!" : "You Lose!";
            addMoveToHistory(`${color} wins the game!`);
            showGameOver();
          }
          debugLog(`executeMove: move complete for ${color} piece #${pieceIndex}`);
          updateOffBoardCounts();
          return true;
        } catch (error) {
          console.error("executeMove error:", error);
          return false;
        }
      }
      function checkSpecialVictoryCondition() {
        debugLog("checkSpecialVictoryCondition: starting");
        const houndsSpecialOccupied = ["B6","B7","B8","B9","B10"].every(label =>
          houndsPieces.some(pos => boardPathHounds[pos] === label)
        );
        const jackalsSpecialOccupied = ["C6","C7","C8","C9"].every(label =>
          jackalsPieces.some(pos => boardPathJackals[pos] === label)
        );
        if (houndsSpecialOccupied) {
          gameOverTextEl.textContent = "Hounds Win by Occupying All Special Spots!";
          addMoveToHistory("Hounds win by occupying all special spots!");
          showGameOver();
          return true;
        }
        if (jackalsSpecialOccupied) {
          gameOverTextEl.textContent = "Jackals Win by Occupying All Special Spots!";
          addMoveToHistory("Jackals win by occupying all special spots!");
          showGameOver();
          return true;
        }
        debugLog("checkSpecialVictoryCondition: none met");
        return false;
      }

      /* -------------------------
         Human Input Functions
         ------------------------- */
      function humanRollDice() {
        debugLog("humanRollDice: clicked");
        if (gameState !== "playing" || currentTurn !== humanSide || diceRolled) {
          debugLog("humanRollDice: conditions not met");
          return;
        }
        if (unusedRoll !== null && unusedRollOwner === humanSide) {
          debugLog("humanRollDice: discarding unused roll (" + unusedRoll + ") for normal roll.");
          unusedRoll = null;
          unusedRollOwner = null;
          updateUnusedRollButton();
        }
        const rollValue = rollDice();
        processDiceRoll(rollValue);
      }
      function handleBoardClick(e) {
        debugLog("handleBoardClick: event triggered");
        if (gameState !== "playing" || currentTurn !== humanSide || ((!diceRolled) && unusedRoll === null)) {
          debugLog("handleBoardClick: conditions not met");
          return;
        }
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        const ownPieces = (humanSide === "hounds") ? houndsPieces : jackalsPieces;
        const boardPathSide = (humanSide === "hounds") ? boardPathHounds : boardPathJackals;
        for (let i = 0; i < ownPieces.length; i++) {
          const pos = ownPieces[i];
          if (pos === -1 || pos === 29) continue;
          const label = boardPathSide[pos];
          const sq = boardSquares[label];
          if (mx >= sq.x - 25 && mx <= sq.x + 25 && my >= sq.y - 25 && my <= sq.y + 25) {
            debugLog("handleBoardClick: piece at index " + i + " clicked");
            tryMovePiece(i, humanSide);
            return;
          }
        }
        debugLog("handleBoardClick: no valid piece clicked");
      }
      function tryMovePiece(pieceIndex, color) {
        debugLog("tryMovePiece: called for " + color + " piece " + pieceIndex);
        if (gameState !== "playing" || currentTurn !== humanSide || ((!diceRolled) && unusedRoll === null) || color !== currentTurn) {
          showTemporaryMessage("Can't move right now!");
          debugLog("tryMovePiece: conditions not met");
          return;
        }
        const usingUnused = (unusedRoll !== null && unusedRollOwner === humanSide);
        const rollUsed = usingUnused ? unusedRoll : currentDiceRoll;
        debugLog("tryMovePiece: using roll = " + rollUsed + (usingUnused ? " (unused)" : " (normal)"));
        const pieces = (color === "hounds") ? houndsPieces : jackalsPieces;
        if (pieces[pieceIndex] === -1) {
          if (rollUsed === 6 && canLandOn(0, color)) {
            debugLog("tryMovePiece: legal release move for piece " + pieceIndex);
            executeMove(pieceIndex, 0, color);
            addMoveToHistory(`${color} placed piece on board using roll of ${rollUsed}.`);
            diceRolled = false;
            currentDiceRoll = 0;
            if (usingUnused) {
              unusedRoll = null;
              unusedRollOwner = null;
              updateUnusedRollButton();
              updateTurn(); // Do not switch turn.
            } else {
              completeMove(false);
            }
            redrawPlayScreen();
          } else {
            showTemporaryMessage("Cannot place piece! Need a 6.");
            debugLog("tryMovePiece: illegal release move, rollUsed = " + rollUsed);
          }
          return;
        }
        let opts = getMoveOptions(rollUsed, color);
        let moveOpt = opts.find(o => o.pieceIndex === pieceIndex);
        if (moveOpt) {
          debugLog("tryMovePiece: legal move for piece " + pieceIndex);
          executeMove(pieceIndex, moveOpt.toPos, color);
          addMoveToHistory(`${color} moved with roll (${rollUsed}).`);
          diceRolled = false;
          currentDiceRoll = 0;
          if (usingUnused) {
            unusedRoll = null;
            unusedRollOwner = null;
            updateUnusedRollButton();
            updateTurn(); // Do not switch turn.
          } else {
            completeMove(false);
          }
          redrawPlayScreen();
        } else {
          showTemporaryMessage("Illegal move with this roll!");
          debugLog("tryMovePiece: piece " + pieceIndex + " cannot move with roll " + rollUsed);
        }
      }

      /* -------------------------
         AI Functions
         ------------------------- */
      function aiAutoRoll() {
        debugLog("aiAutoRoll: starting for " + currentTurn);
        if (gameState !== "playing" || currentTurn === humanSide) { debugLog("aiAutoRoll: conditions not met"); return; }
        if (unusedRoll !== null && unusedRollOwner === "jackals") {
          debugLog("AI auto-using unused roll: " + unusedRoll);
          processDiceRoll(unusedRoll);
          unusedRoll = null;
          unusedRollOwner = null;
          return;
        }
        let rollVal = rollDice();
        processDiceRoll(rollVal);
        setTimeout(() => aiMakeMove(() => {
          if (extraTurn) {
            debugLog("aiAutoRoll: extra turn granted.");
            extraTurn = false;
            completeMove(false);
          } else {
            currentTurn = "hounds";
            updateTurn();
          }
        }), 2000);
      }
      function aiMakeMove(callback = null) {
        debugLog("aiMakeMove: starting for " + currentTurn);
        let opts = getMoveOptions(currentDiceRoll, currentTurn);
        if (opts.length === 0) {
          showTemporaryMessage("AI has no moves. Passing turn...");
          unusedRoll = currentDiceRoll;
          unusedRollOwner = "hounds";
          diceRolled = false;
          currentDiceRoll = 0;
          currentTurn = "hounds";
          updateTurn();
          if (callback) callback();
          return;
        }
        let pick;
        if (aiDifficulty === "easy") {
          pick = opts[Math.floor(Math.random() * opts.length)];
        } else if (aiDifficulty === "medium") {
          let captureMoves = opts.filter(o => {
            return houndsPieces.includes(o.toPos);
          });
          pick = (captureMoves.length > 0)
            ? captureMoves[Math.floor(Math.random() * captureMoves.length)]
            : opts[Math.floor(Math.random() * opts.length)];
        } else if (aiDifficulty === "hard") {
          let captureMoves = opts.filter(o => {
            return houndsPieces.includes(o.toPos);
          });
          if (captureMoves.length > 0) {
            pick = captureMoves[Math.floor(Math.random() * captureMoves.length)];
          } else {
            pick = opts.reduce((best, o) => (o.fromPos < best.fromPos ? o : best), opts[0]);
          }
        }
        debugLog("aiMakeMove: chosen move: piece " + pick.pieceIndex + " to " + pick.toPos);
        if (!executeMove(pick.pieceIndex, pick.toPos, currentTurn)) {
          currentTurn = "hounds";
          diceRolled = false;
          currentDiceRoll = 0;
          updateTurn();
          return;
        }
        redrawPlayScreen();
        if (extraTurn) {
          addMoveToHistory(`${currentTurn} gets another turn!`);
          showTemporaryMessage(`${currentTurn} gets another turn!`);
          completeMove(false);
        } else {
          currentTurn = "hounds";
          updateTurn();
        }
        debugLog("aiMakeMove: complete");
        if (callback) callback();
      }

      /* -------------------------
         Temporary Message Overlay
         ------------------------- */
      function showTemporaryMessage(msg) {
        debugLog("showTemporaryMessage: " + msg);
        const overlay = document.getElementById("diceMessageOverlay");
        overlay.textContent = msg;
        overlay.style.display = "block";
        setTimeout(() => { overlay.style.display = "none"; }, 2000);
      }

      /* -------------------------
         Overlay and Navigation Functions
         ------------------------- */
      function hideAllScreens() {
        menuScreenEl.style.display = "none";
        instructionsScreenEl.style.display = "none";
        difficultyScreenEl.style.display = "none";
        gameOverScreenEl.style.display = "none";
        debugLog("hideAllScreens: all screens hidden");
      }
      function showMenu() {
        hideAllScreens();
        gameState = "menu";
        menuScreenEl.style.display = "flex";
        debugLog("showMenu: Menu shown");
      }
      function showInstructions() {
        hideAllScreens();
        gameState = "instructions";
        instructionsScreenEl.style.display = "flex";
        currentInstructionsPage = 0;
        updateInstructions();
        debugLog("showInstructions: Instructions shown");
      }
      function showDifficultyScreen() {
        hideAllScreens();
        gameState = "selectDifficulty";
        difficultyScreenEl.style.display = "flex";
        debugLog("showDifficultyScreen: Difficulty screen shown");
      }
      function setDifficulty(d) {
        aiDifficulty = d;
        debugLog("setDifficulty: set to " + d);
        startPlaying();
      }
      function startPlaying() {
        debugLog("startPlaying: starting game");
        hideAllScreens();
        gameState = "playing";
        initPieces();
        currentTurn = "hounds";  // Human always starts.
        nextPlayer = "jackals";
        diceRolled = false;
        currentDiceRoll = 0;
        extraTurn = false;
        unusedRoll = null;
        unusedRollOwner = null;
        addMoveToHistory("Hounds Turn! Roll dice...");
        showTemporaryMessage("Hounds Turn! Roll dice...");
        redrawPlayScreen();
        debugLog("startPlaying: game started");
      }
      function showGameOver() {
        hideAllScreens();
        gameState = "gameover";
        gameOverScreenEl.style.display = "flex";
        debugLog("showGameOver: Game over shown");
      }

      /* -------------------------
         Event Listeners for UI
         ------------------------- */
      document.getElementById("newGameBtn").onclick = () => showDifficultyScreen();
      document.getElementById("instructionsBtn").onclick = () => showInstructions();
      const gameOverNewGameBtn = document.getElementById("gameOverNewGameBtn");
      if (gameOverNewGameBtn) { gameOverNewGameBtn.onclick = () => showDifficultyScreen(); }
      rollDiceBtn.addEventListener("click", humanRollDice);
      canvas.addEventListener("click", handleBoardClick);
      document.getElementById("easyBtn").onclick = () => setDifficulty("easy");
      document.getElementById("mediumBtn").onclick = () => setDifficulty("medium");
      document.getElementById("hardBtn").onclick = () => setDifficulty("hard");
      setCustomDiceBtn.addEventListener("click", () => {
        if (gameState !== "playing" || currentTurn !== humanSide || diceRolled) return;
        const customValue = parseInt(customDiceInput.value);
        if (isNaN(customValue) || customValue < 1 || customValue > 6) {
          showTemporaryMessage("Invalid dice value!");
          debugLog("Custom dice input invalid");
          return;
        }
        processDiceRoll(customValue);
        let opts = getMoveOptions(currentDiceRoll, currentTurn);
        if (opts.length === 0) {
          showTemporaryMessage("No legal moves. Your roll is passed to your opponent.");
          addMoveToHistory(`No legal moves. ${currentTurn} passes roll (${currentDiceRoll}) to opponent.`);
          if (currentTurn === humanSide) {
            nextPlayer = "jackals";
            unusedRoll = currentDiceRoll;
            unusedRollOwner = nextPlayer;
            currentTurn = nextPlayer;
          } else {
            currentTurn = "hounds";
          }
          diceRolled = false;
          currentDiceRoll = 0;
          updateTurn();
        }
      });
      document.getElementById("releaseHoundBtn").onclick = releaseHound;
      document.addEventListener("keydown", (e) => {
        let key = e.key.toLowerCase();
        if (gameState === "selectDifficulty") {
          if (key === "e") setDifficulty("easy");
          else if (key === "m") setDifficulty("medium");
          else if (key === "h") setDifficulty("hard");
        } else if (gameState === "playing") {
          if (key === "r" && currentTurn === humanSide && !diceRolled && unusedRoll === null) {
            humanRollDice();
          } else if (key === "m") {
            initPieces();
            showMenu();
          }
        } else if (gameState === "instructions" || gameState === "gameover") {
          if (key === "m") {
            initPieces();
            showMenu();
          }
        }
      });

      function releaseHound() {
        debugLog("releaseHound: called");
        if (currentTurn !== "hounds") {
          showTemporaryMessage("Not your turn!");
          debugLog("releaseHound: not hounds turn");
          return;
        }
        if (!diceRolled || currentDiceRoll !== 6) {
          showTemporaryMessage("Must roll a 6 to release!");
          debugLog("releaseHound: invalid dice for release");
          return;
        }
        const index = houndsPieces.findIndex(p => p === -1);
        if (index === -1) {
          showTemporaryMessage("No off-board hounds left!");
          debugLog("releaseHound: no off-board hounds");
          return;
        }
        debugLog("releaseHound: releasing piece index " + index);
        tryMovePiece(index, "hounds");
      }

      function mainLoop() {
        if (gameState === "playing") {
          redrawPlayScreen();
          rollDiceBtn.style.display = (currentTurn === humanSide) ? "inline-block" : "none";
        }
        requestAnimationFrame(mainLoop);
      }
      function startAll() {
        showMenu();
        requestAnimationFrame(mainLoop);
        debugLog("startAll: Main loop started.");
      }
      startAll();
    });
  </script>
</body>
</html>
