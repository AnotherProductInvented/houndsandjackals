<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented: Hounds and Jackals</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    /* Global Reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #fafafa;
      font-family: "Papyrus", cursive, serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1, h2, p {
      text-align: center;
      color: #8b4513;
    }
    /* Layout Wrapper */
    #gameWrapper {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      width: 100%;
      margin: 20px;
    }
    /* Left Panel (Dice Controls) */
    #leftPanel {
      min-width: 150px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Right Panel (Move History) */
    #rightPanel {
      min-width: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Game Container */
#gameContainer {
  position: relative;
  width: 840px;
  height: 500px;

  padding: 20px;
  background: #fff;
  border: 10px double #8b4513;
  border-radius: 6px;
  margin-bottom: 20px;
  overflow-y: auto; /* ðŸ‘ˆ Optional: if overflow ever happens, scrollbars will show */
  background: linear-gradient(to bottom, #f5e6ca, #ecd8b5);
}

canvas {
  display: block;
  background: radial-gradient(#fef9e7, #e8d6a4);
  margin: auto;
  border-radius: 8px;
  box-shadow: 0 0 15px rgba(0,0,0,0.2);
}

    /* Overlays */
    .overlayScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      border: 10px double #8b4513;
      border-radius: 6px;
      z-index: 10;
      overflow-y: auto;
    }
    .overlayScreen.active {
      display: flex;
    }
    /* Instructions overlay additional buttons */
    #instructionsContent {
      font-size: 20px;
      margin: 10px;
    }
    #instructionsNav {
      margin-top: 10px;
    }
    /* Buttons */
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
      background: #ffcc00;
      border: none;
      border-radius: 6px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      color: #333;
      font-family: "Papyrus", cursive, serif;
    }
    /* Dice Display */
    #diceRollDisplay {
      font-size: 24px;
      padding: 10px;
      border: 2px solid #8b4513;
      border-radius: 6px;
      background: #fff;
      margin-bottom: 10px;
    }
    /* Move History */
    #moveHistory {
      font-size: 16px;
      padding: 10px;
      border: 2px solid #8b4513;
      border-radius: 6px;
      background: #fff;
      max-height: 400px;
      overflow-y: auto;
      width: 200px;
      text-align: left;
    }
    /* Temporary message overlay */
    #diceMessageOverlay {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 20px;
      background: rgba(255,255,255,0.9);
      border: 2px solid #8b4513;
      border-radius: 6px;
      font-family: "Papyrus", cursive, serif;
      font-size: 28px;
      color: #8b4513;
      display: none;
      z-index: 1500;
    }
    /* Logo */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <!-- Header Banner -->
  <div class="header-title">
    <h2>Another Product Invented</h2>
    <h1>Hounds and Jackals</h1>
  </div>

  <div id="gameWrapper">
    <!-- Left Panel: Dice Controls -->
    <div id="leftPanel">
      <div id="diceRollDisplay">Dice: -</div>
      <button id="rollDiceBtn">Roll Dice</button>
    </div>

    <!-- Center Panel: Game Container -->
    <div id="gameContainer">
      <!-- Temporary Message Overlay -->
      <div id="diceMessageOverlay"></div>
      <!-- Overlays -->
      <div id="menuScreen" class="overlayScreen active">
        <h1>Hounds and Jackals</h1>
        <button id="newGameBtn">New Game</button>
        <button id="instructionsBtn">Instructions</button>
      </div>
      <div id="instructionsScreen" class="overlayScreen">
        <div id="instructionsContent"></div>
        <div id="instructionsNav">
          <button id="instructionsPrevBtn">Previous</button>
          <button id="instructionsNextBtn">Next</button>
        </div>
      </div>
      <div id="difficultyScreen" class="overlayScreen">
        <p>Select AI Difficulty:</p>
        <button id="easyBtn">Easy</button>
        <button id="mediumBtn">Medium</button>
        <button id="hardBtn">Hard</button>
      </div>
      <div id="gameOverScreen" class="overlayScreen">
        <h2 id="gameOverText"></h2>
        <button id="gameOverNewGameBtn">New Game</button>
        <p>Press [M] to return to the Main Menu.</p>
      </div>
      <canvas id="gameCanvas" width="820" height="320"></canvas>



    </div>

    <!-- Right Panel: Move History -->
    <div id="rightPanel">
      <div id="moveHistory">Moves:<br></div>
    </div>
  </div>

  <img id="logo" src="logo.png" alt="Logo">

  <script>
    'use strict';
    const debugMode = true;
    function debugLog(msg) {
      if (debugMode) console.log("[DEBUG]", msg);
    }
    const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

    /***********************************
     * 1) Board & Canvas Setup
     ***********************************/
const boardSquares = {};
const boardPath = [];

// Board settings
const SLOT_RADIUS = 14;
const SLOT_SPACING = 44;
const START_X = 40;
const START_Y = 100;

// Rows A & D: 15 peg holes each
for (let i = 1; i <= 15; i++) {
  boardSquares[`A${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y };
  boardPath.push(`A${i}`);
}
for (let i = 1; i <= 15; i++) {
  boardSquares[`D${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 3.6 };
  boardPath.push(`D${i}`);
}

// Rows B & C: 10 peg holes each (aligned just under A1 and D1, better spacing)
for (let i = 1; i <= 10; i++) {
  boardSquares[`B${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 1.2 };
  boardPath.push(`B${i}`);
}
for (let i = 1; i <= 10; i++) {
  boardSquares[`C${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 2.4 };
  boardPath.push(`C${i}`);
}


// Section E1â€“E9: Symmetrical "C" arch from A15 to D15
const archPoints = 9;
const xStart = boardSquares["A15"].x;
const xEnd = boardSquares["D15"].x;
const centerX = xStart + (xEnd - xStart) / 2;
const archHeight = SLOT_SPACING * 3; // How high the arch dips â€” increase to widen curve

for (let i = 0; i < archPoints; i++) {
  const label = `E${i + 1}`;
  const t = i / (archPoints - 1); // 0 to 1
  const x = xStart + t * (xEnd - xStart);

  // Make a nice symmetrical "C" using a sine wave mirrored top-bottom
  const mirror = Math.abs(i - (archPoints - 1) / 2);
  const y = boardSquares["A15"].y + archHeight * Math.sin((mirror / ((archPoints - 1) / 2)) * (Math.PI / 2));

  boardSquares[label] = { x, y };
  boardPath.push(label);
}






    /***********************************
     * 2) Game State Variables
     ***********************************/
    let gameState = "menu";  // "menu", "instructions", "selectDifficulty", "playing", "gameover"
    let humanSide = null;    // "hounds" or "jackals"
    let aiDifficulty = "medium";  // "easy", "medium", "hard"
    let currentTurn = null;       // "hounds" or "jackals"
    let currentDiceRoll = 0;
    let diceRolled = false;
    let extraTurn = false;
    let nextPlayer = null;
    const NUM_PIECES = 5;
    let houndsPieces = [], jackalsPieces = [];
    let moveHistory = [];
    let lastMove = null;
    debugLog("Game state variables initialized.");

    /***********************************
     * 3) DOM Elements & Overlays
     ***********************************/
    const diceRollDisplay = document.getElementById("diceRollDisplay");
    const rollDiceBtn = document.getElementById("rollDiceBtn");
    const moveHistoryDiv = document.getElementById("moveHistory");
    const menuScreen = document.getElementById("menuScreen");
    const instructionsScreen = document.getElementById("instructionsScreen");
    const difficultyScreen = document.getElementById("difficultyScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const gameOverText = document.getElementById("gameOverText");
    const instructionsContent = document.getElementById("instructionsContent");
    const instructionsPrevBtn = document.getElementById("instructionsPrevBtn");
    const instructionsNextBtn = document.getElementById("instructionsNextBtn");
    debugLog("DOM elements loaded.");

    /***********************************
     * 4) Instructions (3 Pages)
     ***********************************/
    const instructionsPages = [
      `Page 1 â€“ Gameplay Overview:<br>
      â€¢ Each player has 5 pieces.<br>
      â€¢ To enter a piece onto the board, you must roll a 1 or 6.<br>
      â€¢ Pieces move along a 30â€‘square serpentine path.<br>
      â€¢ Landing on an opponentâ€™s piece (if not on a safe zone) captures it (sends it offâ€‘board).<br>
      â€¢ Rolling a 6 grants an extra turn.`,
      `Page 2 â€“ Special Rules:<br>
      â€¢ You cannot land on a square occupied by your own piece (except safe zones).<br>
      â€¢ Exact roll is required to land on the final square.<br>
      â€¢ Safe zones (marked with a star) protect pieces from capture.`,
      `Page 3 â€“ Winning & Additional Details:<br>
      â€¢ The first player to get all 5 pieces to the final square wins.<br>
      â€¢ If no legal moves are available, the turn is forfeited.<br>
      â€¢ Press [M] at any time to return to the Main Menu.`
    ];
    let currentInstructionsPage = 0;
    function updateInstructions() {
      instructionsContent.innerHTML = instructionsPages[currentInstructionsPage];
      instructionsPrevBtn.style.display = (currentInstructionsPage === 0) ? "none" : "inline-block";
      instructionsNextBtn.style.display = (currentInstructionsPage === instructionsPages.length - 1) ? "none" : "inline-block";
      debugLog("Instructions updated to page " + (currentInstructionsPage + 1));
    }
    instructionsPrevBtn.onclick = () => {
      if (currentInstructionsPage > 0) {
        currentInstructionsPage--;
        updateInstructions();
      }
    };
    instructionsNextBtn.onclick = () => {
      if (currentInstructionsPage < instructionsPages.length - 1) {
        currentInstructionsPage++;
        updateInstructions();
      }
    };

    /***********************************
     * 5) External Images for Pieces
     ***********************************/
    let houndsImg = new Image();
    houndsImg.src = "hounds.png";  // your custom image for hounds
    houndsImg.crossOrigin = "anonymous";
    let jackalsImg = new Image();
    jackalsImg.src = "jackals.png"; // your custom image for jackals
    jackalsImg.crossOrigin = "anonymous";
    houndsImg.onload = () => debugLog("Hounds image loaded.");
    jackalsImg.onload = () => debugLog("Jackals image loaded.");

    /***********************************
     * 6) Initialization of Pieces
     ***********************************/
    function initPieces() {
      houndsPieces = Array(NUM_PIECES).fill(-1);  // pieces off-board
      jackalsPieces = Array(NUM_PIECES).fill(-1);
      lastMove = null;
      moveHistory = [];
      updateMoveHistoryDisplay();
      debugLog("Pieces initialized.");
    }

    /***********************************
     * 7) Dice Function
     ***********************************/
    function rollDice() {
      const roll = Math.floor(Math.random() * 6) + 1;
      debugLog("Dice rolled: " + roll);
      return roll;
    }

    /***********************************
     * 8) Drawing Functions
     ***********************************/
function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  Object.entries(boardSquares).forEach(([label, sq], index) => {
    // Base slot
    ctx.beginPath();
    ctx.arc(sq.x, sq.y, SLOT_RADIUS, 0, Math.PI * 2);
    let grad = ctx.createRadialGradient(sq.x, sq.y, 5, sq.x, sq.y, SLOT_RADIUS);
    grad.addColorStop(0, "#fcebbd");
    grad.addColorStop(1, "#b38b4d");
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = "#6b4e2e";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = "#000";
    ctx.font = "12px Arial";
    ctx.fillText(label, sq.x, sq.y - 18);


    // Draw slot number
    
    // Safe zone mark
    if (sq.safe) {
      drawStar(sq.x, sq.y, 6, 12, 6, "#ffcc00", "#000", 2);
    }
  });
}


    function drawStar(cx, cy, spikes, outerRadius, innerRadius, fillColor, strokeColor, lineWidth) {
      let rot = Math.PI / 2 * 3;
      let x = cx, y = cy;
      let step = Math.PI / spikes;
      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;
        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }
function drawPieces() {
  houndsPieces.forEach((pos, i) => {
    if (pos === -1 || pos === 29) return;
    const label = boardPath[pos];
    const sq = boardSquares[label];
    const cx = sq.x;
    const cy = sq.y;
    ctx.save();
    ctx.shadowColor = "rgba(0,0,0,0.3)";
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(cx, cy, 22, 0, Math.PI * 2);
    const grad = ctx.createRadialGradient(cx - 8, cy - 8, 5, cx, cy, 24);
    grad.addColorStop(0, "#ffffff");
    grad.addColorStop(1, "#bcbcbc");
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#444";
    ctx.stroke();
    ctx.fillStyle = "#222";
    ctx.font = "bold 14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(i + 1, cx, cy + 5);
    ctx.restore();
  });

  jackalsPieces.forEach((pos, i) => {
    if (pos === -1 || pos === 29) return;
    const label = boardPath[pos];
    const sq = boardSquares[label];
    const cx = sq.x;
    const cy = sq.y;


    ctx.save();
    ctx.shadowColor = "rgba(0,0,0,0.3)";
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(cx, cy, 22, 0, Math.PI * 2);
    const grad = ctx.createRadialGradient(cx - 8, cy - 8, 5, cx, cy, 24);
    grad.addColorStop(0, "#ffcccc");
    grad.addColorStop(1, "#d93f3f");
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#444";
    ctx.stroke();
    ctx.fillStyle = "#fff";
    ctx.font = "bold 14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(i + 1, cx, cy + 5);
    ctx.restore();
  });

  debugLog("Pieces drawn.");
}

    function redrawPlayScreen() {
      drawBoard();
      drawPieces();
      updateDiceRollDisplay();
      updateMoveHistoryDisplay();
      debugLog("Play screen redrawn.");
    }
    function updateDiceRollDisplay() {
      diceRollDisplay.textContent = `Dice: ${currentDiceRoll || "-"}`;
    }
    function addMoveToHistory(txt) {
      moveHistory.push(txt);
      if (moveHistory.length > 5) moveHistory.shift();
      updateMoveHistoryDisplay();
      debugLog("Move added: " + txt);
    }
    function updateMoveHistoryDisplay() {
      moveHistoryDiv.innerHTML = "Moves:<br>" + moveHistory.join("<br>");
    }

    /***********************************
     * 9) Movement & Rules Functions
     ***********************************/
    // Pieces start off-board at -1. To enter, must roll 1 or 6.
    function getValidMove(piecePos, diceValue, color) {
      debugLog(`Validating move for ${color} piece at ${piecePos} with dice ${diceValue}`);
      if (piecePos === -1) {
        if (diceValue === 1 || diceValue === 6) return 0;
        return null;
      }
      let target = piecePos + diceValue;
      if (target > 29) return null; // must land exactly on final square (29)
      return target;
    }
    function canLandOn(pos, color) {
      let own = (color === "hounds") ? houndsPieces : jackalsPieces;
      if (own.includes(pos)) return false;
      return true;
    }
    function getMoveOptions(diceValue, color) {
      let opts = [];
      let own = (color === "hounds") ? houndsPieces : jackalsPieces;
      for (let i = 0; i < own.length; i++) {
        let pos = own[i];
        let newPos = getValidMove(pos, diceValue, color);
        if (newPos === null) continue;
        if (!canLandOn(newPos, color)) continue;
        opts.push({ pieceIndex: i, fromPos: pos, toPos: newPos });
      }
      debugLog(`${color} move options: ${JSON.stringify(opts)}`);
      return opts;
    }
    function executeMove(pieceIndex, toPos, color) {
      let own = (color === "hounds") ? houndsPieces : jackalsPieces;
      let opp = (color === "hounds") ? jackalsPieces : houndsPieces;
      let fromPos = own[pieceIndex];
      // Capture rule: if landing on opponentâ€™s piece (and square not safe), capture it.
      if (toPos !== 0 && toPos !== 29) {
        if (opp.includes(toPos)) {
          let sq = boardSquares[path[toPos]];
          if (!sq.safe) {
            let oppIdx = opp.indexOf(toPos);
            opp[oppIdx] = -1;
            addMoveToHistory(`${color} captured opponent at square ${toPos+1}`);
            debugLog(`${color} captured opponent piece at ${toPos}`);
          }
        }
      }
      own[pieceIndex] = toPos;
      addMoveToHistory(`${color} moved piece #${pieceIndex+1} from ${fromPos===-1?"off-board":fromPos+1} to ${toPos+1}`);
      lastMove = { fromPos, toPos, color, pieceIndex };
      if (currentDiceRoll === 6) {
        extraTurn = true;
        nextPlayer = color;
      } else {
        extraTurn = false;
        nextPlayer = (color === "hounds") ? "jackals" : "hounds";
      }
      let finished = own.filter(p => p === 29).length;
      if (finished === NUM_PIECES) {
        gameOverText.textContent = (color === humanSide) ? "You Win!" : "You Lose!";
        addMoveToHistory(`${color} wins the game!`);
        showGameOver();
      }
      debugLog(`${color} executed move for piece ${pieceIndex} to ${toPos}`);
    }

    /***********************************
     * 10) Turn Management
     ***********************************/
    function endTurn(isHumanTurn) {
      diceRolled = false;
      currentDiceRoll = 0;
      setTimeout(() => {
        currentTurn = nextPlayer;
        addMoveToHistory(`${currentTurn} Turn! Roll dice...`);
        redrawPlayScreen();
        if (currentTurn !== humanSide) {
          setTimeout(aiAutoRoll, 2000);
        }
        debugLog("Turn ended. Next turn: " + currentTurn);
      }, isHumanTurn ? 1000 : 2000);
    }

    /***********************************
     * 11) Human Interaction
     ***********************************/
    function humanRollDice() {
      if (gameState !== "playing") return;
      if (currentTurn !== humanSide) return;
      if (diceRolled) return;
      currentDiceRoll = rollDice();
      diceRolled = true;
      addMoveToHistory(`${humanSide} rolled ${currentDiceRoll}`);
      showTemporaryMessage(`${humanSide} rolled ${currentDiceRoll}`);
      redrawPlayScreen();
      let opts = getMoveOptions(currentDiceRoll, currentTurn);
      if (opts.length === 0) {
        showTemporaryMessage("No legal moves. Passing turn...");
        nextPlayer = (currentTurn === "hounds") ? "jackals" : "hounds";
        diceRolled = false;
        currentDiceRoll = 0;
        endTurn(true);
      }
    }
    function handleBoardClick(e) {
      if (gameState !== "playing") return;
      if (currentTurn !== humanSide) return;
      if (!diceRolled) return;
      let opts = getMoveOptions(currentDiceRoll, currentTurn);
      if (opts.length === 0) return;
      let rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left, my = e.clientY - rect.top;
      let own = (currentTurn === "hounds") ? houndsPieces : jackalsPieces;
      for (let i = 0; i < own.length; i++) {
        let pos = own[i];
        if (pos === 29) continue;
        let sqIdx = path[pos === -1 ? 0 : pos];
        let sq = boardSquares[sqIdx];
        let cx = sq.x + sq.w/2, cy = sq.y + sq.h/2;
        let dx = mx - cx, dy = my - cy;
        if (Math.sqrt(dx*dx + dy*dy) <= 24) {
          let found = opts.find(o => o.pieceIndex === i);
          if (!found) {
            showTemporaryMessage("Illegal move!");
            return;
          }
          if (!executeMove(i, found.toPos, currentTurn)) return;
          redrawPlayScreen();
          showTemporaryMessage(`${currentTurn} moved piece #${i+1}`);
          endTurn(true);
          return;
        }
      }
    }

    /***********************************
     * 12) AI Turn
     ***********************************/
    function aiAutoRoll() {
      if (gameState !== "playing") return;
      if (currentTurn === humanSide) return;
      if (!diceRolled) {
        currentDiceRoll = rollDice();
        diceRolled = true;
        addMoveToHistory(`${currentTurn} rolled ${currentDiceRoll}`);
        showTemporaryMessage(`${currentTurn} rolled ${currentDiceRoll}`);
        redrawPlayScreen();
        setTimeout(aiMakeMove, 2000);
      }
    }
    function aiMakeMove() {
      let opts = getMoveOptions(currentDiceRoll, currentTurn);
      if (opts.length === 0) {
        showTemporaryMessage("AI has no moves. Passing turn...");
        nextPlayer = (currentTurn === "hounds") ? "jackals" : "hounds";
        diceRolled = false;
        currentDiceRoll = 0;
        endTurn(false);
        return;
      }
      let pick;
      if (aiDifficulty === "easy") {
        pick = opts[Math.floor(Math.random() * opts.length)];
      } else if (aiDifficulty === "medium") {
        let captureMoves = opts.filter(o => {
          let opp = (currentTurn === "hounds") ? jackalsPieces : houndsPieces;
          return opp.includes(o.toPos);
        });
        pick = (captureMoves.length > 0) ? captureMoves[Math.floor(Math.random() * captureMoves.length)] : opts[Math.floor(Math.random() * opts.length)];
      } else if (aiDifficulty === "hard") {
        let captureMoves = opts.filter(o => {
          let opp = (currentTurn === "hounds") ? jackalsPieces : houndsPieces;
          return opp.includes(o.toPos);
        });
        if (captureMoves.length > 0) {
          pick = captureMoves[Math.floor(Math.random() * captureMoves.length)];
        } else {
          pick = opts.reduce((best, o) => (o.fromPos < best.fromPos ? o : best), opts[0]);
        }
      }
      if (!executeMove(pick.pieceIndex, pick.toPos, currentTurn)) {
        nextPlayer = (currentTurn === "hounds") ? "jackals" : "hounds";
        diceRolled = false;
        currentDiceRoll = 0;
        endTurn(false);
        return;
      }
      redrawPlayScreen();
      if (extraTurn) {
        showTemporaryMessage(`${currentTurn} goes again!`);
        diceRolled = false;
        currentDiceRoll = 0;
        aiAutoRoll();
      } else {
        endTurn(false);
      }
    }

    /***********************************
     * 13) Temporary Messages
     ***********************************/
    function showTemporaryMessage(msg) {
      const overlay = document.getElementById("diceMessageOverlay");
      overlay.textContent = msg;
      overlay.style.display = "block";
      setTimeout(() => { overlay.style.display = "none"; }, 2000);
      debugLog("Message: " + msg);
    }

    /***********************************
     * 14) Overlays & Navigation
     ***********************************/
    function hideAllScreens() {
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu() {
      hideAllScreens();
      gameState = "menu";
      menuScreen.style.display = "flex";
      debugLog("Showing Menu.");
    }
    function showInstructions() {
      hideAllScreens();
      gameState = "instructions";
      instructionsScreen.style.display = "flex";
      currentInstructionsPage = 0;
      updateInstructions();
      debugLog("Showing Instructions.");
    }
    function showDifficultyScreen() {
      hideAllScreens();
      gameState = "selectDifficulty";
      difficultyScreen.style.display = "flex";
      debugLog("Showing Difficulty Screen.");
    }
    function setDifficulty(d) {
      aiDifficulty = d;
      startPlaying();
      debugLog("Difficulty set to " + d);
    }
    function startPlaying() {
      hideAllScreens();
      gameState = "playing";
      initPieces();
      currentTurn = "hounds"; // Hounds always start (if human is hounds, human goes first)
      diceRolled = false;
      currentDiceRoll = 0;
      extraTurn = false;
      addMoveToHistory("Hounds Turn! Roll dice...");
      showTemporaryMessage("Hounds Turn! Roll dice...");
      redrawPlayScreen();
      if (currentTurn !== humanSide) {
        setTimeout(aiAutoRoll, 2000);
      }
      debugLog("Game started.");
    }
    function showGameOver() {
      hideAllScreens();
      gameState = "gameover";
      gameOverScreen.style.display = "flex";
      debugLog("Game Over.");
    }

    /***********************************
     * 15) Buttons & Keyboard
     ***********************************/
    // For side selection, we assume human picks via external controls.
    // For simplicity, we assume human always plays hounds.
    humanSide = "hounds";
    document.getElementById("newGameBtn").onclick = () => showDifficultyScreen();
    document.getElementById("instructionsBtn").onclick = () => showInstructions();
    document.getElementById("gameOverNewGameBtn") && (document.getElementById("gameOverNewGameBtn").onclick = () => showDifficultyScreen());
    rollDiceBtn.addEventListener("click", humanRollDice);
    canvas.addEventListener("mousedown", handleBoardClick);
    document.getElementById("easyBtn").onclick = () => setDifficulty("easy");
    document.getElementById("mediumBtn").onclick = () => setDifficulty("medium");
    document.getElementById("hardBtn").onclick = () => setDifficulty("hard");

    document.addEventListener("keydown", (e) => {
      let key = e.key.toLowerCase();
      if (gameState === "selectDifficulty") {
        if (key === "e") setDifficulty("easy");
        else if (key === "m") setDifficulty("medium");
        else if (key === "h") setDifficulty("hard");
      } else if (gameState === "playing") {
        if (key === "r" && currentTurn === humanSide && !diceRolled) {
          humanRollDice();
        } else if (key === "m") {
          initPieces();
          showMenu();
        }
      } else if (gameState === "instructions" || gameState === "gameover") {
        if (key === "m") {
          initPieces();
          showMenu();
        }
      }
    });

    /***********************************
     * 16) Main Loop
     ***********************************/
    function mainLoop() {
      if (gameState === "playing") {
        redrawPlayScreen();
        rollDiceBtn.style.display = (currentTurn === humanSide) ? "inline-block" : "none";
      }
      requestAnimationFrame(mainLoop);
    }
    function startAll() {
      showMenu();
      requestAnimationFrame(mainLoop);
      debugLog("Main loop started.");
    }
    window.addEventListener("load", startAll);
  </script>
</body>
</html>
