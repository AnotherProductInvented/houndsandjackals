<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hounds and Jackals</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    /* Global Reset & Basic Styles */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #fafafa;
      font-family: "Papyrus", cursive, serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1, h2, p { text-align: center; color: #8b4513; }
    /* Layout */
    #gameWrapper {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      width: 100%;
      margin: 20px;
    }
    /* Left Panel */
    #leftPanel {
      min-width: 150px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #releaseControls { margin-top: 15px; }
    #releaseControls button { margin: 5px; padding: 5px 10px; font-size: 16px; }
    #offBoardCounts { margin-top: 10px; font-size: 16px; }
    #unusedRollBtn {
      display: none;
      margin: 5px;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      background: #ffcc00;
      border: none;
      border-radius: 6px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      color: #333;
      font-family: "Papyrus", cursive, serif;
    }
    /* Right Panel */
    #rightPanel {
      min-width: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #moveHistory {
      font-size: 16px;
      padding: 10px;
      border: 2px solid #8b4513;
      border-radius: 6px;
      background: #fff;
      max-height: 400px;
      overflow-y: auto;
      width: 200px;
      text-align: left;
      user-select: text;
      white-space: pre-wrap;
      word-wrap: break-word;
      cursor: text;
      position: relative;
      z-index: 100;
    }
    #copyHistoryBtn {
      margin-top: 10px;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      background: #ffcc00;
      border: none;
      border-radius: 6px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      color: #333;
      font-family: "Papyrus", cursive, serif;
      z-index: 100;
    }
    /* Center Panel */
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 900px;
      padding: 20px 20px 80px 20px;
      background: linear-gradient(to bottom, #f5e6ca, #ecd8b5);
      border: 10px double #8b4513;
      border-radius: 6px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: radial-gradient(#fef9e7, #e8d6a4);
      margin: auto;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }
    /* Overlays */
    .overlayScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      border: 10px double #8b4513;
      border-radius: 6px;
      z-index: 10;
      overflow-y: auto;
    }
    .overlayScreen.active { display: flex; }
    /* Instructions */
    #instructionsContent { font-size: 20px; margin: 10px; }
    #instructionsNav { margin-top: 10px; }
    /* Button Styles */
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
      background: #ffcc00;
      border: none;
      border-radius: 6px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      color: #333;
      font-family: "Papyrus", cursive, serif;
    }
    /* Dice Display */
    #diceRollDisplay {
      font-size: 24px;
      padding: 10px;
      border: 2px solid #8b4513;
      border-radius: 6px;
      background: #fff;
      margin-bottom: 10px;
    }
    /* Temporary Message Overlay */
    #diceMessageOverlay {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 20px;
      background: rgba(255,255,255,0.9);
      border: 2px solid #8b4513;
      border-radius: 6px;
      font-family: "Papyrus", cursive, serif;
      font-size: 28px;
      color: #8b4513;
      display: none;
      z-index: 1500;
    }
    /* Logo */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <div class="header-title">
    <h2>Another Product Invented</h2>
    <h1>Hounds and Jackals</h1>
  </div>
  <div id="gameWrapper">
    <div id="leftPanel">
      <div id="diceRollDisplay">Dice: -</div>
      <button id="rollDiceBtn">Roll Dice</button>
      <button id="unusedRollBtn">Use Unused Roll</button>
      <button id="ignoreUnusedRollBtn" style="display: none;">Ignore Unused Roll</button>
      <input type="number" id="customDiceInput" min="1" max="6" placeholder="Set Dice (1-6)">
      <button id="setCustomDiceBtn">Use Custom Dice</button>
      <div id="releaseControls">
        <button id="releaseHoundBtn">Release Hound</button>
      </div>
      <div id="offBoardCounts">
        <span id="houndsCount">Hounds Off-board: 5</span><br>
        <span id="jackalsCount">Jackals Off-board: 5</span>
      </div>
    </div>
    <div id="gameContainer">
      <div id="diceMessageOverlay"></div>
      <div id="menuScreen" class="overlayScreen active">
        <h1>Hounds and Jackals</h1>
        <button id="newGameBtn">New Game</button>
        <button id="instructionsBtn">Instructions</button>
      </div>
      <div id="instructionsScreen" class="overlayScreen">
        <div id="instructionsContent"></div>
        <div id="instructionsNav">
          <button id="instructionsPrevBtn">Previous</button>
          <button id="instructionsNextBtn">Next</button>
        </div>
      </div>
      <div id="difficultyScreen" class="overlayScreen">
        <p>Select AI Difficulty:</p>
        <button id="easyBtn">Easy</button>
        <button id="mediumBtn">Medium</button>
        <button id="hardBtn">Hard</button>
      </div>
      <div id="gameOverScreen" class="overlayScreen">
        <h2 id="gameOverText"></h2>
        <button id="gameOverNewGameBtn">New Game</button>
        <p>Press [M] to return to the Main Menu.</p>
      </div>
      <div id="jackalsTray" style="display: flex; gap: 10px; justify-content: center; margin-bottom: 10px;"></div>
      <canvas id="gameCanvas" width="820" height="320" style="width: 100%; height: auto;"></canvas>
      <div id="houndsTray" style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;"></div>
    </div>
    <div id="rightPanel">
      <div id="moveHistory" contenteditable="true">Moves:<br></div>
      <button id="copyHistoryBtn">Copy History</button>
    </div>
  </div>
  <img id="logo" src="logo.png" alt="Logo">
  <script>
    // ─── UTILITY FUNCTIONS ─────────────────────────────
    function removeWhiteBackground(image, callback) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = image.width;
      tempCanvas.height = image.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(image, 0, 0);
      const imgData = tempCtx.getImageData(0, 0, image.width, image.height);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
          if (data[i] >= 240 && data[i+1] >= 240 && data[i+2] >= 240) {
              data[i+3] = 0;
          }
      }
      tempCtx.putImageData(imgData, 0, 0);
      const newImage = new Image();
      newImage.src = tempCanvas.toDataURL();
      newImage.onload = () => callback(newImage);
    }

    // ─── GLOBAL VARIABLES & NEW TURN STATES ─────────────
    // Instead of using currentTurn with only two options,
    // we now use turnState with four possibilities:
    // "hounds", "hounds_unused", "jackals", "jackals_unused"
    let turnState = "hounds";
    const humanSide = "hounds";  // Human always plays as hounds.
    let aiDifficulty = "medium";
    let currentDiceRoll = 0;
    let diceRolled = false;
    let extraTurn = false;
    let NUM_PIECES = 5;
    let houndsPieces = [];
    let jackalsPieces = [];
    let moveHistory = [];
    let lastTurnReported = "";
    let unusedRoll = null;
    let unusedRollOwner = null;
    let aiTimeout = null;
    
    // ─── GAME INITIALIZATION & BOARD SETUP ───────────────
    // (Board setup code remains the same.)
    const boardPath = [];
    const boardSquares = {};
    const boardPathHounds = ["E5","E6","E7","E8","E9",
          "D15","D14","D13","D12","D11","D10","D9","D8","D7","D6","D5","D4","D3","D2","D1",
          "C1","C2","C3","C4","C5","C6","C7","C8","C9","C10"];
    const boardPathJackals = ["E5","E4","E3","E2","E1",
          "A15","A14","A13","A12","A11","A10","A9","A8","A7","A6","A5","A4","A3","A2","A1",
          "B1","B2","B3","B4","B5","B6","B7","B8","B9","B10"];
    const SLOT_RADIUS = 7, SLOT_SPACING = 44, START_X = 40, START_Y = 100;
    
    for (let i = 1; i <= 15; i++) {
      boardSquares[`A${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y };
      boardPath.push(`A${i}`);
    }
    for (let i = 1; i <= 15; i++) {
      boardSquares[`D${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 3.6 };
      boardPath.push(`D${i}`);
    }
    for (let i = 1; i <= 10; i++) {
      boardSquares[`B${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 1.2 };
      boardPath.push(`B${i}`);
    }
    for (let i = 1; i <= 10; i++) {
      boardSquares[`C${i}`] = { x: START_X + (i - 1) * SLOT_SPACING, y: START_Y + SLOT_SPACING * 2.4 };
      boardPath.push(`C${i}`);
    }
    const archCenters = [
      { x: boardSquares["A15"].x + SLOT_SPACING * 0.65, y: boardSquares["A15"].y + SLOT_SPACING * 0.2 },
      { x: boardSquares["A15"].x + SLOT_SPACING * 1.3,  y: boardSquares["A15"].y + SLOT_SPACING * 0.4 },
      { x: boardSquares["A15"].x + SLOT_SPACING * 2.0,  y: boardSquares["A15"].y + SLOT_SPACING * 0.7 },
      { x: boardSquares["A15"].x + SLOT_SPACING * 2.6,  y: boardSquares["A15"].y + SLOT_SPACING * 1.2 },
      { x: boardSquares["A15"].x + SLOT_SPACING * 3.2,  y: boardSquares["A15"].y + SLOT_SPACING * 1.9 },
      { x: boardSquares["A15"].x + SLOT_SPACING * 2.6,  y: boardSquares["A15"].y + SLOT_SPACING * 2.6 },
      { x: boardSquares["A15"].x + SLOT_SPACING * 2.0,  y: boardSquares["A15"].y + SLOT_SPACING * 3.1 },
      { x: boardSquares["A15"].x + SLOT_SPACING * 1.3,  y: boardSquares["A15"].y + SLOT_SPACING * 3.4 },
      { x: (boardSquares["D15"].x + boardSquares["A15"].x + SLOT_SPACING * 1.3) / 2,
        y: (boardSquares["D15"].y + boardSquares["A15"].y + SLOT_SPACING * 3.4) / 2 }
    ];
    for (let i = 0; i < 9; i++) {
      boardSquares[`E${i + 1}`] = archCenters[i];
      boardPath.push(`E${i + 1}`);
    }
    
    // ─── PIECE IMAGES ─────────────────────────────────────────────
    let houndsImg = new Image();
    let jackalsImg = new Image();
    houndsImg.src = "hounds.png";
    jackalsImg.src = "jackals.png";
    
    houndsImg.onload = () => {
      removeWhiteBackground(houndsImg, (cleaned) => {
          houndsImg = cleaned;
          if (jackalsImg.complete) prepareTrayImages(() => redrawPlayScreen());
      });
    };
    jackalsImg.onload = () => {
      removeWhiteBackground(jackalsImg, (cleaned) => {
          jackalsImg = cleaned;
          if (houndsImg.complete) prepareTrayImages(() => redrawPlayScreen());
      });
    };
    
    // ─── INITIALIZATION FUNCTION ───────────────────────────────────
    function initPieces() {
      houndsPieces = Array(NUM_PIECES).fill(-1);
      jackalsPieces = Array(NUM_PIECES).fill(-1);
      lastTurnReported = "";
      moveHistory = [];
      updateMoveHistoryDisplay();
      updateTrays();
      updateOffBoardCounts();
    }
    
    // ─── DICE & UNUSED ROLL LOGIC ─────────────────────────────────
    function rollDice() {
      const roll = Math.floor(Math.random() * 6) + 1;
      debugLog("rollDice: rolled " + roll);
      return roll;
    }
    
    function processDiceRoll(diceValue) {
      if (diceValue < 1 || diceValue > 6) {
          debugLog("processDiceRoll: invalid diceValue = " + diceValue);
          showTemporaryMessage("Invalid dice roll!");
          return;
      }
      const rollValue = guaranteedRoll(diceValue);
      debugLog("processDiceRoll: final rollValue = " + rollValue);
      currentDiceRoll = rollValue;
      diceRolled = true;
      addMoveToHistory(`${turnState} rolled ${rollValue}`);
      showTemporaryMessage(`${turnState} rolled ${rollValue}`);
      redrawPlayScreen();
      
      // Determine legal moves.
      let opts = getMoveOptions(rollValue, turnState.replace("_unused",""));
      debugLog("processDiceRoll: legal moves count = " + opts.length);
      if (opts.length === 0) {
          // If no legal moves, switch to opponent's unused state.
          if (turnState === "hounds") {
              turnState = "jackals_unused";
              unusedRoll = rollValue;
              unusedRollOwner = turnState;
          } else if (turnState === "jackals") {
              turnState = "hounds_unused";
              unusedRoll = rollValue;
              unusedRollOwner = turnState;
          } else {
              // If already in an unused state and still no moves, just clear the unused roll
              unusedRoll = null;
              unusedRollOwner = null;
              // And go to the opponent's normal state.
              turnState = (turnState === "hounds_unused") ? "jackals" : "hounds";
          }
          addMoveToHistory(`${turnState} turn (unused) due to no legal moves.`);
          updateTurn();
          return;
      }
    }
    
    // ─── DRAWING FUNCTIONS ─────────────────────────────────────────
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      Object.entries(boardSquares).forEach(([label, sq]) => {
          ctx.beginPath();
          ctx.arc(sq.x, sq.y, SLOT_RADIUS, 0, Math.PI * 2);
          let grad;
          if (["B6", "B7", "B8", "B9", "B10"].includes(label)) {
              grad = ctx.createRadialGradient(sq.x, sq.y, 5, sq.x, sq.y, SLOT_RADIUS);
              grad.addColorStop(0, "#aad4ff");
              grad.addColorStop(1, "#005fa3");
          } else if (["C6", "C7", "C8", "C9", "C10"].includes(label)) {
              grad = ctx.createRadialGradient(sq.x, sq.y, 5, sq.x, sq.y, SLOT_RADIUS);
              grad.addColorStop(0, "#aaf0aa");
              grad.addColorStop(1, "#007a3d");
          } else {
              grad = ctx.createRadialGradient(sq.x, sq.y, 5, sq.x, sq.y, SLOT_RADIUS);
              grad.addColorStop(0, "#fcebbd");
              grad.addColorStop(1, "#b38b4d");
          }
          ctx.fillStyle = grad;
          ctx.fill();
          ctx.strokeStyle = "#6b4e2e";
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.fillText(label, sq.x, sq.y - 18);
      });
      ["A5", "A15", "D5", "D15", "E5"].forEach(label => {
          const sq = boardSquares[label];
          ctx.beginPath();
          ctx.arc(sq.x, sq.y, SLOT_RADIUS + 3, 0, Math.PI * 2);
          ctx.lineWidth = 3;
          ctx.strokeStyle = "#8b0000";
          ctx.stroke();
      });
      drawDoubleArrow(boardSquares["A10"], boardSquares["B5"], "between");
      drawDoubleArrow(boardSquares["D10"], boardSquares["C5"], "between");
      drawDoubleArrow(boardSquares["B1"], boardSquares["B3"]);
      drawDoubleArrow(boardSquares["C1"], boardSquares["C3"], "below");
    }
    
    function drawDoubleArrow(from, to, direction = "above") {
      let midX = (from.x + to.x) / 2, midY;
      if (direction === "above") {
          midY = (from.y + to.y) / 2 - SLOT_SPACING * 0.75;
      } else if (direction === "below") {
          midY = (from.y + to.y) / 2 + SLOT_SPACING * 0.75;
      } else if (direction === "between") {
          midY = (from.y + to.y) / 2;
          midX += (from.x < to.x ? SLOT_SPACING * 0.9 : -SLOT_SPACING * 0.9);
      }
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.quadraticCurveTo(midX, midY, to.x, to.y);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
      function drawArrowhead(x, y, angle) {
          const len = 10;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x - len * Math.cos(angle - Math.PI/6),
                     y - len * Math.sin(angle - Math.PI/6));
          ctx.lineTo(x - len * Math.cos(angle + Math.PI/6),
                     y - len * Math.sin(angle + Math.PI/6));
          ctx.closePath();
          ctx.fillStyle = "#000";
          ctx.fill();
      }
      function getCurveAngle(x0, y0, cx, cy, x1, y1, t = 0.99) {
          const dx = 2 * (1 - t) * (cx - x0) + 2 * t * (x1 - cx);
          const dy = 2 * (1 - t) * (cy - y0) + 2 * t * (y1 - cy);
          return Math.atan2(dy, dx);
      }
      const angleStart = getCurveAngle(to.x, to.y, midX, midY, from.x, from.y);
      drawArrowhead(from.x, from.y, angleStart);
      const angleEnd = getCurveAngle(from.x, from.y, midX, midY, to.x, to.y);
      drawArrowhead(to.x, to.y, angleEnd);
    }
    
    function drawPieces() {
      houndsPieces.forEach((pos, i) => {
          if (pos === -1 || pos === 29) return;
          const label = boardPathHounds[pos];
          const sq = boardSquares[label];
          ctx.drawImage(houndsImg, sq.x - 20, sq.y - 20, 40, 40);
      });
      jackalsPieces.forEach((pos, i) => {
          if (pos === -1 || pos === 29) return;
          const label = boardPathJackals[pos];
          const sq = boardSquares[label];
          ctx.drawImage(jackalsImg, sq.x - 20, sq.y - 20, 40, 40);
      });
    }
    
    function redrawPlayScreen() {
      drawBoard();
      drawPieces();
      updateDiceRollDisplay();
      updateMoveHistoryDisplay();
      updateTrays();
    }
    
    function updateDiceRollDisplay() {
      diceRollDisplayEl.textContent = `Dice: ${
          (currentDiceRoll !== 0) ? currentDiceRoll :
          (unusedRoll !== null && unusedRollOwner === turnState) ? unusedRoll : "-"
      }`;
      debugLog("updateDiceRollDisplay: currentDiceRoll = " + currentDiceRoll);
    }
    
    function addMoveToHistory(txt) {
      if (!txt.includes("Turn! Roll dice...") || lastTurnReported !== turnState) {
          moveHistory.push(txt);
          if (txt.includes("Turn! Roll dice...")) {
              lastTurnReported = turnState;
          }
      }
      updateMoveHistoryDisplay();
      debugLog("addMoveToHistory: " + txt);
    }
    
    function updateMoveHistoryDisplay() {
      moveHistoryDiv.innerHTML = "Moves:<br>" + moveHistory.join("<br>");
    }
    
    // ─── UNUSED ROLL HANDLING ───────────────────────────────
    function updateUnusedRollButton() {
      // Only show unused roll buttons if we are in an *_unused state and it’s the human’s turn.
      const shouldShow = (
          gameState === "playing" &&
          (turnState === "hounds_unused" || turnState === "jackals_unused") &&
          (unusedRoll !== null) &&
          (unusedRoll >= 1 && unusedRoll <= 6)
      );
      if (shouldShow) {
          unusedRollBtn.style.display = "inline-block";
          unusedRollBtn.textContent = "Use Unused Roll (" + unusedRoll + ")";
          ignoreUnusedRollBtn.style.display = "inline-block";
      } else {
          unusedRollBtn.style.display = "none";
          ignoreUnusedRollBtn.style.display = "none";
      }
    }
    
    function attemptUnusedRoll() {
      if (unusedRoll !== null && unusedRollOwner === turnState && turnState !== humanSide) {
          debugLog("AI auto-using unused roll: " + unusedRoll);
          processDiceRoll(unusedRoll);
          unusedRoll = null;
          unusedRollOwner = null;
          return true;
      }
      return false;
    }
    
    // ─── TURN UPDATING ───────────────────────────────────────────
    function updateTurn() {
      currentDiceRoll = 0;
      diceRolled = false;
      rollDiceBtn.style.display = "none";
      unusedRollBtn.style.display = "none";
      ignoreUnusedRollBtn.style.display = "none";
    
      // If in an unused state, show unused roll buttons and do NOT auto-roll.
      if (turnState === "hounds_unused" || turnState === "jackals_unused") {
          addMoveToHistory(`${turnState} turn: Unused roll available.`);
          showTemporaryMessage(`${turnState} turn: Unused roll available.`);
          updateUnusedRollButton();
          if (turnState !== humanSide) {
              aiTimeout = setTimeout(() => {
                  // If AI does nothing in 6 seconds, automatically ignore the unused roll.
                  debugLog("AI auto-ignores the unused roll: " + unusedRoll);
                  unusedRoll = null;
                  unusedRollOwner = null;
                  // Switch to the opponent's normal turn.
                  turnState = (turnState === "hounds_unused") ? "jackals" : "hounds";
                  updateTurn();
              }, 6000);
          }
      } else { // Normal turn states ("hounds" or "jackals")
          addMoveToHistory(`${turnState}'s Turn! Roll dice...`);
          showTemporaryMessage(`${turnState}'s Turn! Roll dice...`);
          if (turnState === humanSide) {
              rollDiceBtn.style.display = "inline-block";
          } else {
              aiTimeout = setTimeout(aiAutoRoll, 2000);
          }
      }
      redrawPlayScreen();
    }
    
    // ─── TRAY & OFF-BOARD UPDATES ──────────────────────────────
    let imagesReady = false;
    function prepareTrayImages(callback) {
      let readyCount = 0;
      function checkReady() {
          readyCount++;
          if (readyCount === 2) { imagesReady = true; callback(); }
      }
      removeWhiteBackground(houndsImg, (cleaned) => { houndsImg = cleaned; checkReady(); });
      removeWhiteBackground(jackalsImg, (cleaned) => { jackalsImg = cleaned; checkReady(); });
    }
    function updateTrays() {
      if (!imagesReady) return;
      const houndsTray = document.getElementById("houndsTray");
      const jackalsTray = document.getElementById("jackalsTray");
      houndsTray.innerHTML = "";
      jackalsTray.innerHTML = "";
      updateOffBoardCounts();
    }
    function updateOffBoardCounts() {
      const hCount = houndsPieces.filter(p => p === -1).length;
      const jCount = jackalsPieces.filter(p => p === -1).length;
      document.getElementById("houndsCount").textContent = "Hounds Off-board: " + hCount;
      document.getElementById("jackalsCount").textContent = "Jackals Off-board: " + jCount;
    }
    
    // ─── MOVEMENT & RULES FUNCTIONS ─────────────────────────────
    function getValidMove(piecePos, diceValue, color) {
      if (piecePos === -1) return (diceValue === 6 ? 0 : null);
      let target = piecePos + diceValue;
      if (target > 29) return null;
      return target;
    }
    
    function canLandOn(pos, color) {
      let own = (color === "hounds") ? houndsPieces : jackalsPieces;
      return !own.includes(pos);
    }
    
    function getMoveOptions(diceValue, color) {
      let opts = [];
      let own = (color === "hounds") ? houndsPieces : jackalsPieces;
      for (let i = 0; i < own.length; i++) {
          let pos = own[i];
          let newPos = getValidMove(pos, diceValue, color);
          if (newPos === null || !canLandOn(newPos, color)) continue;
          let label = (color === "hounds") ? boardPathHounds[newPos] : boardPathJackals[newPos];
          if ((color === "hounds" && ["B6", "B7", "B8", "B9", "B10"].includes(label)) ||
              (color === "jackals" && ["C6", "C7", "C8", "C9"].includes(label)))
              continue;
          opts.push({ pieceIndex: i, fromPos: pos, toPos: newPos });
      }
      return opts;
    }
    
    function executeMove(pieceIndex, toPos, color) {
      try {
          let own = (color === "hounds") ? houndsPieces : jackalsPieces;
          let fromPos = own[pieceIndex];
          const teleportPairs = {
              "A10": "B5", "B5": "A10",
              "D10": "C5", "C5": "D10",
              "B1": "B3", "B3": "B1",
              "C1": "C3", "C3": "C1"
          };
          own[pieceIndex] = toPos;
          let currentLabel = (color === "hounds") ? boardPathHounds[toPos] : boardPathJackals[toPos];
          if (teleportPairs[currentLabel]) {
              let targetLabel = teleportPairs[currentLabel];
              let targetIndex = (color === "hounds") ? boardPathHounds.indexOf(targetLabel) : boardPathJackals.indexOf(targetLabel);
              if (targetIndex !== -1 && canLandOn(targetIndex, color)) {
                  own[pieceIndex] = targetIndex;
                  addMoveToHistory(`${color} teleported from ${currentLabel} to ${targetLabel}`);
                  showTemporaryMessage(`${color} teleported to ${targetLabel}`);
                  toPos = targetIndex;
              }
          }
          addMoveToHistory(`${color} moved piece #${pieceIndex+1} from ${fromPos === -1 ? "off-board" : fromPos+1} to ${toPos+1}`);
          const landedLabel = (color === "hounds") ? boardPathHounds[toPos] : boardPathJackals[toPos];
          if (["A5", "A15", "D5", "D15", "E5"].includes(landedLabel)) {
              extraTurn = true;
              addMoveToHistory(`${color} landed on ${landedLabel}, gets another turn!`);
              showTemporaryMessage(`${color} gets another turn!`);
          }
          let finished = own.filter(p => p === 29).length;
          if (finished === NUM_PIECES) {
              if (checkSpecialVictoryCondition()) return true;
              gameOverTextEl.textContent = (color === humanSide) ? "You Win!" : "You Lose!";
              addMoveToHistory(`${color} wins the game!`);
              showGameOver();
          }
          updateOffBoardCounts();
          return true;
      } catch (error) {
          console.error("executeMove error:", error);
          return false;
      }
    }
    
    function checkSpecialVictoryCondition() {
      const houndsSpecialOccupied = ["B6","B7","B8","B9","B10"].every(label =>
          houndsPieces.some(pos => boardPathHounds[pos] === label)
      );
      const jackalsSpecialOccupied = ["C6","C7","C8","C9"].every(label =>
          jackalsPieces.some(pos => boardPathJackals[pos] === label)
      );
      if (houndsSpecialOccupied) {
          gameOverTextEl.textContent = "Hounds Win by Occupying All Special Spots!";
          addMoveToHistory("Hounds win by occupying all special spots!");
          showGameOver();
          return true;
      }
      if (jackalsSpecialOccupied) {
          gameOverTextEl.textContent = "Jackals Win by Occupying All Special Spots!";
          addMoveToHistory("Jackals win by occupying all special spots!");
          showGameOver();
          return true;
      }
      return false;
    }
    
    // ─── HUMAN INPUT FUNCTIONS ─────────────────────────────────────
    function humanRollDice() {
      if (gameState !== "playing" || turnState !== humanSide || diceRolled) return;
      // In case an unused roll is present on human side, we now let it remain
      const rollValue = rollDice();
      processDiceRoll(rollValue);
    }
    
    function handleBoardClick(e) {
      if (gameState !== "playing" || turnState !== humanSide || ((!diceRolled) && (turnState !== humanSide + "_unused"))) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      const ownPieces = (humanSide === "hounds") ? houndsPieces : jackalsPieces;
      const boardPathSide = (humanSide === "hounds") ? boardPathHounds : boardPathJackals;
      for (let i = 0; i < ownPieces.length; i++) {
          const pos = ownPieces[i];
          if (pos === -1 || pos === 29) continue;
          const label = boardPathSide[pos];
          const sq = boardSquares[label];
          if (mx >= sq.x - 25 && mx <= sq.x + 25 && my >= sq.y - 25 && my <= sq.y + 25) {
              tryMovePiece(i, humanSide);
              return;
          }
      }
    }
    
    function tryMovePiece(pieceIndex, color) {
      if (gameState !== "playing" || turnState.replace("_unused","") !== humanSide || ((!diceRolled) && (turnState !== humanSide + "_unused"))) {
          showTemporaryMessage("Can't move right now!");
          return;
      }
      const usingUnused = (turnState.endsWith("_unused"));
      const rollUsed = usingUnused ? unusedRoll : currentDiceRoll;
      const pieces = (color === "hounds") ? houndsPieces : jackalsPieces;
      if (pieces[pieceIndex] === -1) { // release move
          if (rollUsed === 6 && canLandOn(0, color)) {
              executeMove(pieceIndex, 0, color);
              addMoveToHistory(`${color} placed piece on board using roll of ${rollUsed}.`);
              diceRolled = false;
              currentDiceRoll = 0;
              if (usingUnused) {
                  unusedRoll = null;
                  unusedRollOwner = null;
              }
              // After a move, if extraTurn is not granted, switch from normal to the opponent’s normal state;
              // if we are in an unused state, after using it, clear it and then switch.
              if (!extraTurn) {
                  if (turnState === "hounds" || turnState === "hounds_unused")
                      turnState = "jackals";
                  else
                      turnState = "hounds";
              }
              updateTurn();
          } else {
              showTemporaryMessage("Cannot place piece! Need a 6.");
          }
          return;
      }
      let opts = getMoveOptions(rollUsed, color);
      let moveOpt = opts.find(o => o.pieceIndex === pieceIndex);
      if (moveOpt) {
          executeMove(pieceIndex, moveOpt.toPos, color);
          addMoveToHistory(`${color} moved with roll (${rollUsed}).`);
          diceRolled = false;
          currentDiceRoll = 0;
          if (usingUnused) {
              unusedRoll = null;
              unusedRollOwner = null;
          }
          if (!extraTurn) {
              if (turnState === "hounds" || turnState === "hounds_unused")
                  turnState = "jackals";
              else
                  turnState = "hounds";
          }
          updateTurn();
      }
    }
    
    // ─── AI FUNCTIONS ─────────────────────────────────────────────
    function aiAutoRoll() {
      if (gameState !== "playing" || (turnState === humanSide || turnState === humanSide + "_unused")) return;
      if (turnState.endsWith("_unused")) {
          processDiceRoll(unusedRoll);
          unusedRoll = null;
          unusedRollOwner = null;
          return;
      }
      let rollVal = rollDice();
      processDiceRoll(rollVal);
      setTimeout(() => aiMakeMove(() => {
          if (extraTurn) {
              extraTurn = false;
              updateTurn();
          } else {
              turnState = "hounds";  // switch back to hounds after AI turn
              updateTurn();
          }
      }), 2000);
    }
    
    function aiMakeMove(callback = null) {
      let opts = getMoveOptions(currentDiceRoll, turnState);
      if (opts.length === 0) {
          showTemporaryMessage("AI has no moves. Passing turn...");
          unusedRoll = currentDiceRoll;
          // Switch to opponent’s normal state:
          turnState = (turnState === "jackals") ? "hounds" : "jackals";
          diceRolled = false;
          currentDiceRoll = 0;
          updateTurn();
          if (callback) callback();
          return;
      }
      let pick;
      if (aiDifficulty === "easy") {
          pick = opts[Math.floor(Math.random() * opts.length)];
      } else if (aiDifficulty === "medium") {
          let captureMoves = opts.filter(o => houndsPieces.includes(o.toPos));
          pick = (captureMoves.length > 0)
              ? captureMoves[Math.floor(Math.random() * captureMoves.length)]
              : opts[Math.floor(Math.random() * opts.length)];
      } else if (aiDifficulty === "hard") {
          let captureMoves = opts.filter(o => houndsPieces.includes(o.toPos));
          if (captureMoves.length > 0) {
              pick = captureMoves[Math.floor(Math.random() * captureMoves.length)];
          } else {
              pick = opts.reduce((best, o) => (o.fromPos < best.fromPos ? o : best), opts[0]);
          }
      }
      if (!executeMove(pick.pieceIndex, pick.toPos, turnState.replace("_unused",""))) {
          turnState = "hounds";
          diceRolled = false;
          currentDiceRoll = 0;
          updateTurn();
          return;
      }
      if (extraTurn) {
          addMoveToHistory(`${turnState} gets another turn!`);
          showTemporaryMessage(`${turnState} gets another turn!`);
          // In extra turn, remain in the same state.
      } else {
          turnState = "hounds";  // After AI move, return to hounds turn.
      }
      updateTurn();
      if (callback) callback();
    }
    
    // ─── TEMPORARY MESSAGE OVERLAY ──────────────────────────────
    function showTemporaryMessage(msg) {
      const overlay = document.getElementById("diceMessageOverlay");
      overlay.textContent = msg;
      overlay.style.display = "block";
      setTimeout(() => { overlay.style.display = "none"; }, 2000);
    }
    
    // ─── OVERLAY & NAVIGATION FUNCTIONS ───────────────────────────
    function hideAllScreens() {
      menuScreenEl.style.display = "none";
      instructionsScreenEl.style.display = "none";
      difficultyScreenEl.style.display = "none";
      gameOverScreenEl.style.display = "none";
    }
    
    function showMenu() {
      hideAllScreens();
      gameState = "menu";
      menuScreenEl.style.display = "flex";
    }
    
    function showInstructions() {
      hideAllScreens();
      gameState = "instructions";
      instructionsScreenEl.style.display = "flex";
      updateInstructions();
    }
    
    function showDifficultyScreen() {
      hideAllScreens();
      gameState = "selectDifficulty";
      difficultyScreenEl.style.display = "flex";
    }
    
    function setDifficulty(d) {
      aiDifficulty = d;
      startPlaying();
    }
    
    function startPlaying() {
      hideAllScreens();
      gameState = "playing";
      initPieces();
      turnState = "hounds"; // Human always starts normally.
      diceRolled = false;
      currentDiceRoll = 0;
      extraTurn = false;
      unusedRoll = null;
      unusedRollOwner = null;
      addMoveToHistory("Hounds Turn! Roll dice...");
      showTemporaryMessage("Hounds Turn! Roll dice...");
      redrawPlayScreen();
      updateTurn();
    }
    
    function showGameOver() {
      hideAllScreens();
      gameState = "gameover";
      gameOverScreenEl.style.display = "flex";
    }
    
    function updateInstructions() {
      const instructionsPages = [
          "Welcome to Hounds and Jackals! Use dice rolls to move your pieces.",
          "Roll a 6 to bring a piece onto the board. Land on special tiles for bonus moves.",
          "Teleport between linked tiles. Avoid blocking your own path!",
          "Win by getting all your pieces to the end or claiming all special tiles."
      ];
      if (currentInstructionsPage < 0) currentInstructionsPage = 0;
      if (currentInstructionsPage >= instructionsPages.length) currentInstructionsPage = instructionsPages.length - 1;
      instructionsContentEl.textContent = instructionsPages[currentInstructionsPage];
    }
    
    // ─── EVENT LISTENERS ─────────────────────────────────────────────
    document.getElementById("newGameBtn").onclick = () => showDifficultyScreen();
    document.getElementById("instructionsBtn").onclick = () => showInstructions();
    const gameOverNewGameBtn = document.getElementById("gameOverNewGameBtn");
    if (gameOverNewGameBtn) { gameOverNewGameBtn.onclick = () => showDifficultyScreen(); }
    rollDiceBtn.addEventListener("click", humanRollDice);
    canvas.addEventListener("click", handleBoardClick);
    document.getElementById("easyBtn").onclick = () => setDifficulty("easy");
    document.getElementById("mediumBtn").onclick = () => setDifficulty("medium");
    document.getElementById("hardBtn").onclick = () => setDifficulty("hard");
    setCustomDiceBtn.addEventListener("click", () => {
      if (gameState !== "playing" || turnState !== humanSide || diceRolled) return;
      const customValue = parseInt(customDiceInput.value);
      if (isNaN(customValue) || customValue < 1 || customValue > 6) {
          showTemporaryMessage("Invalid dice value!");
          return;
      }
      processDiceRoll(customValue);
      let opts = getMoveOptions(currentDiceRoll, turnState.replace("_unused",""));
      if (opts.length === 0) {
          showTemporaryMessage("No legal moves. Your roll is passed to your opponent.");
          addMoveToHistory(`No legal moves. ${turnState} passes roll (${currentDiceRoll}) to opponent.`);
          if (turnState === "hounds") {
              turnState = "jackals_unused";
              unusedRoll = currentDiceRoll;
              unusedRollOwner = turnState;
          } else {
              turnState = "hounds_unused";
              unusedRoll = currentDiceRoll;
              unusedRollOwner = turnState;
          }
          diceRolled = false;
          currentDiceRoll = 0;
          updateTurn();
      }
    });
    document.getElementById("releaseHoundBtn").onclick = releaseHound;
    document.addEventListener("keydown", (e) => {
      let key = e.key.toLowerCase();
      if (gameState === "selectDifficulty") {
          if (key === "e") setDifficulty("easy");
          else if (key === "m") setDifficulty("medium");
          else if (key === "h") setDifficulty("hard");
      } else if (gameState === "playing") {
          if (key === "r" && turnState === humanSide && !diceRolled) {
              humanRollDice();
          } else if (key === "m") {
              initPieces();
              showMenu();
          }
      } else if (gameState === "instructions" || gameState === "gameover") {
          if (key === "m") {
              initPieces();
              showMenu();
          }
      }
    });
    
    function releaseHound() {
      if (turnState !== "hounds") {
          showTemporaryMessage("Not your turn!");
          return;
      }
      if (!diceRolled || currentDiceRoll !== 6) {
          showTemporaryMessage("Must roll a 6 to release!");
          return;
      }
      const index = houndsPieces.findIndex(p => p === -1);
      if (index === -1) {
          showTemporaryMessage("No off-board hounds left!");
          return;
      }
      tryMovePiece(index, humanSide);
    }
    
    function mainLoop() {
      if (gameState === "playing") {
          redrawPlayScreen();
          if (turnState === humanSide) {
              rollDiceBtn.style.display = "inline-block";
          } else {
              rollDiceBtn.style.display = "none";
          }
      }
      requestAnimationFrame(mainLoop);
    }
    
    function startAll() {
      showMenu();
      requestAnimationFrame(mainLoop);
    }
    
    // Start the game
    startAll();
    
    // ─── DEBUG FUNCTION ─────────────────────────────────────────────
    function debugLog(msg) {
      console.log("[DEBUG]", msg);
    }
    
    // End of code.
  </script>
</body>
</html>
